# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from typing import Dict, IO, List, Optional, Union

import msrest.serialization

from ._purview_catalog_service_restapi_document_enums import *


class ComponentsV9D1InSchemasJsonTypestatisticsPropertiesTypestatisticsAdditionalproperties(msrest.serialization.Model):
    """ComponentsV9D1InSchemasJsonTypestatisticsPropertiesTypestatisticsAdditionalproperties.

    :param count: The entity count of this type.
    :type count: int
    """

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        **kwargs
    ):
        super(ComponentsV9D1InSchemasJsonTypestatisticsPropertiesTypestatisticsAdditionalproperties, self).__init__(**kwargs)
        self.count = count


class JsonAdvancedSearchResult(msrest.serialization.Model):
    """The result of the advanced search result.

    :param search_count: The total number of search results (not the number of documents in a
     single page).
    :type search_count: int
    :param search_facets: A facet list that consists of index fields assetType ,classification,
     classificationCategory, contactId, fileExtension, label, and label. When the facet is specified
     in the request, the value of the facet is returned as an element of @search.facets.
    :type search_facets: ~PurviewCatalog.models.JsonSearchFacetResultValue
    :param value:
    :type value: list[~PurviewCatalog.models.JsonSearchResultValue]
    """

    _attribute_map = {
        'search_count': {'key': '@search\\.count', 'type': 'int'},
        'search_facets': {'key': '@search\\.facets', 'type': 'JsonSearchFacetResultValue'},
        'value': {'key': 'value', 'type': '[JsonSearchResultValue]'},
    }

    def __init__(
        self,
        *,
        search_count: Optional[int] = None,
        search_facets: Optional["JsonSearchFacetResultValue"] = None,
        value: Optional[List["JsonSearchResultValue"]] = None,
        **kwargs
    ):
        super(JsonAdvancedSearchResult, self).__init__(**kwargs)
        self.search_count = search_count
        self.search_facets = search_facets
        self.value = value


class JsonAtlasAttributeDef(msrest.serialization.Model):
    """class that captures details of a struct-attribute.

    :param cardinality: single-valued attribute or multi-valued attribute. Possible values include:
     "SINGLE", "LIST", "SET".
    :type cardinality: str or ~PurviewCatalog.models.JsonCardinality
    :param constraints: An array of constraints.
    :type constraints: list[~PurviewCatalog.models.JsonAtlasConstraintDef]
    :param default_value: The default value of the attribute.
    :type default_value: str
    :param description: The description of the attribute.
    :type description: str
    :param include_in_notification: Determines if it is included in notification.
    :type include_in_notification: bool
    :param is_indexable: Determines if it is indexable.
    :type is_indexable: bool
    :param is_optional: Determines if it is optional.
    :type is_optional: bool
    :param is_unique: Determines if it unique.
    :type is_unique: bool
    :param name: The name of the attribute.
    :type name: str
    :param options: The options for the attribute.
    :type options: dict[str, str]
    :param type_name: The name of the type.
    :type type_name: str
    :param values_max_count: The maximum count of the values.
    :type values_max_count: int
    :param values_min_count: The minimum count of the values.
    :type values_min_count: int
    """

    _attribute_map = {
        'cardinality': {'key': 'cardinality', 'type': 'str'},
        'constraints': {'key': 'constraints', 'type': '[JsonAtlasConstraintDef]'},
        'default_value': {'key': 'defaultValue', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'include_in_notification': {'key': 'includeInNotification', 'type': 'bool'},
        'is_indexable': {'key': 'isIndexable', 'type': 'bool'},
        'is_optional': {'key': 'isOptional', 'type': 'bool'},
        'is_unique': {'key': 'isUnique', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'values_max_count': {'key': 'valuesMaxCount', 'type': 'int'},
        'values_min_count': {'key': 'valuesMinCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        cardinality: Optional[Union[str, "JsonCardinality"]] = None,
        constraints: Optional[List["JsonAtlasConstraintDef"]] = None,
        default_value: Optional[str] = None,
        description: Optional[str] = None,
        include_in_notification: Optional[bool] = None,
        is_indexable: Optional[bool] = None,
        is_optional: Optional[bool] = None,
        is_unique: Optional[bool] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        type_name: Optional[str] = None,
        values_max_count: Optional[int] = None,
        values_min_count: Optional[int] = None,
        **kwargs
    ):
        super(JsonAtlasAttributeDef, self).__init__(**kwargs)
        self.cardinality = cardinality
        self.constraints = constraints
        self.default_value = default_value
        self.description = description
        self.include_in_notification = include_in_notification
        self.is_indexable = is_indexable
        self.is_optional = is_optional
        self.is_unique = is_unique
        self.name = name
        self.options = options
        self.type_name = type_name
        self.values_max_count = values_max_count
        self.values_min_count = values_min_count


class JsonAtlasBaseModelObject(msrest.serialization.Model):
    """The base model object.

    :param guid: The GUID of the object.
    :type guid: str
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasBaseModelObject, self).__init__(**kwargs)
        self.guid = guid


class JsonAtlasBaseTypeDef(msrest.serialization.Model):
    """Base class that captures common-attributes for all Atlas types.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasBaseTypeDef, self).__init__(**kwargs)
        self.category = category
        self.create_time = create_time
        self.created_by = created_by
        self.date_formatter = date_formatter
        self.description = description
        self.guid = guid
        self.name = name
        self.options = options
        self.service_type = service_type
        self.type_version = type_version
        self.update_time = update_time
        self.updated_by = updated_by
        self.version = version
        self.last_modified_ts = last_modified_ts


class JsonAtlasStruct(msrest.serialization.Model):
    """Captures details of struct contents. Not instantiated directly, used only via AtlasEntity, AtlasClassification.

    :param attributes: The attributes of the struct.
    :type attributes: dict[str, object]
    :param type_name: The name of the type.
    :type type_name: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    """

    _attribute_map = {
        'attributes': {'key': 'attributes', 'type': '{object}'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        attributes: Optional[Dict[str, object]] = None,
        type_name: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasStruct, self).__init__(**kwargs)
        self.attributes = attributes
        self.type_name = type_name
        self.last_modified_ts = last_modified_ts


class JsonAtlasClassification(JsonAtlasStruct):
    """An instance of a classification; it doesn't have an identity, this object exists only when associated with an entity.

    :param attributes: The attributes of the struct.
    :type attributes: dict[str, object]
    :param type_name: The name of the type.
    :type type_name: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param entity_guid: The GUID of the entity.
    :type entity_guid: str
    :param entity_status: Status of the entity - can be active or deleted. Deleted entities are not
     removed from Atlas store. Possible values include: "ACTIVE", "DELETED".
    :type entity_status: str or ~PurviewCatalog.models.JsonStatus
    :param propagate: Determines if the classification will be propagated.
    :type propagate: bool
    :param remove_propagations_on_entity_delete: Determines if propagations will be removed on
     entity deletion.
    :type remove_propagations_on_entity_delete: bool
    :param validity_periods: An array of time boundaries indicating validity periods.
    :type validity_periods: list[~PurviewCatalog.models.JsonTimeBoundary]
    :param source: indicate the source who create the classification detail.
    :type source: str
    :param source_details: more detail on source information.
    :type source_details: dict[str, object]
    """

    _attribute_map = {
        'attributes': {'key': 'attributes', 'type': '{object}'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'entity_guid': {'key': 'entityGuid', 'type': 'str'},
        'entity_status': {'key': 'entityStatus', 'type': 'str'},
        'propagate': {'key': 'propagate', 'type': 'bool'},
        'remove_propagations_on_entity_delete': {'key': 'removePropagationsOnEntityDelete', 'type': 'bool'},
        'validity_periods': {'key': 'validityPeriods', 'type': '[JsonTimeBoundary]'},
        'source': {'key': 'source', 'type': 'str'},
        'source_details': {'key': 'sourceDetails', 'type': '{object}'},
    }

    def __init__(
        self,
        *,
        attributes: Optional[Dict[str, object]] = None,
        type_name: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        entity_guid: Optional[str] = None,
        entity_status: Optional[Union[str, "JsonStatus"]] = None,
        propagate: Optional[bool] = None,
        remove_propagations_on_entity_delete: Optional[bool] = None,
        validity_periods: Optional[List["JsonTimeBoundary"]] = None,
        source: Optional[str] = None,
        source_details: Optional[Dict[str, object]] = None,
        **kwargs
    ):
        super(JsonAtlasClassification, self).__init__(attributes=attributes, type_name=type_name, last_modified_ts=last_modified_ts, **kwargs)
        self.entity_guid = entity_guid
        self.entity_status = entity_status
        self.propagate = propagate
        self.remove_propagations_on_entity_delete = remove_propagations_on_entity_delete
        self.validity_periods = validity_periods
        self.source = source
        self.source_details = source_details


class JsonAtlasStructDef(JsonAtlasBaseTypeDef):
    """class that captures details of a struct-type.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param attribute_defs: An array of attribute definitions.
    :type attribute_defs: list[~PurviewCatalog.models.JsonAtlasAttributeDef]
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'attribute_defs': {'key': 'attributeDefs', 'type': '[JsonAtlasAttributeDef]'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        attribute_defs: Optional[List["JsonAtlasAttributeDef"]] = None,
        **kwargs
    ):
        super(JsonAtlasStructDef, self).__init__(category=category, create_time=create_time, created_by=created_by, date_formatter=date_formatter, description=description, guid=guid, name=name, options=options, service_type=service_type, type_version=type_version, update_time=update_time, updated_by=updated_by, version=version, last_modified_ts=last_modified_ts, **kwargs)
        self.attribute_defs = attribute_defs


class JsonAtlasClassificationDef(JsonAtlasStructDef):
    """class that captures details of a classification-type.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param attribute_defs: An array of attribute definitions.
    :type attribute_defs: list[~PurviewCatalog.models.JsonAtlasAttributeDef]
    :param entity_types: Specifying a list of entityType names in the classificationDef, ensures
     that classifications can
     only be applied to those entityTypes.
    
    
     .. raw:: html
    
        <ul>
        <li>Any subtypes of the entity types inherit the restriction</li>
        <li>Any classificationDef subtypes inherit the parents entityTypes restrictions</li>
        <li>Any classificationDef subtypes can further restrict the parents entityTypes
     restrictions by specifying a subset of the entityTypes</li>
        <li>An empty entityTypes list when there are no parent restrictions means there are no
     restrictions</li>
        <li>An empty entityTypes list when there are parent restrictions means that the subtype
     picks up the parents restrictions</li>
        <li>If a list of entityTypes are supplied, where one inherits from another, this will be
     rejected. This should encourage cleaner classificationsDefs</li>
        </ul>.
    :type entity_types: list[str]
    :param sub_types: An array of sub types.
    :type sub_types: list[str]
    :param super_types: An array of super types.
    :type super_types: list[str]
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'attribute_defs': {'key': 'attributeDefs', 'type': '[JsonAtlasAttributeDef]'},
        'entity_types': {'key': 'entityTypes', 'type': '[str]'},
        'sub_types': {'key': 'subTypes', 'type': '[str]'},
        'super_types': {'key': 'superTypes', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        attribute_defs: Optional[List["JsonAtlasAttributeDef"]] = None,
        entity_types: Optional[List[str]] = None,
        sub_types: Optional[List[str]] = None,
        super_types: Optional[List[str]] = None,
        **kwargs
    ):
        super(JsonAtlasClassificationDef, self).__init__(category=category, create_time=create_time, created_by=created_by, date_formatter=date_formatter, description=description, guid=guid, name=name, options=options, service_type=service_type, type_version=type_version, update_time=update_time, updated_by=updated_by, version=version, last_modified_ts=last_modified_ts, attribute_defs=attribute_defs, **kwargs)
        self.entity_types = entity_types
        self.sub_types = sub_types
        self.super_types = super_types


class JsonPlist(msrest.serialization.Model):
    """Paginated-list, for returning search results.

    :param list: An array of objects.
    :type list: list[object]
    :param page_size: The size of the page.
    :type page_size: int
    :param sort_by: The sorted by field.
    :type sort_by: str
    :param sort_type: to specify whether the result should be sorted? If yes, whether asc or desc.
     Possible values include: "NONE", "ASC", "DESC".
    :type sort_type: str or ~PurviewCatalog.models.JsonSortType
    :param start_index: The start index of the page.
    :type start_index: long
    :param total_count: The total count of items.
    :type total_count: long
    """

    _attribute_map = {
        'list': {'key': 'list', 'type': '[object]'},
        'page_size': {'key': 'pageSize', 'type': 'int'},
        'sort_by': {'key': 'sortBy', 'type': 'str'},
        'sort_type': {'key': 'sortType', 'type': 'str'},
        'start_index': {'key': 'startIndex', 'type': 'long'},
        'total_count': {'key': 'totalCount', 'type': 'long'},
    }

    def __init__(
        self,
        *,
        list: Optional[List[object]] = None,
        page_size: Optional[int] = None,
        sort_by: Optional[str] = None,
        sort_type: Optional[Union[str, "JsonSortType"]] = None,
        start_index: Optional[int] = None,
        total_count: Optional[int] = None,
        **kwargs
    ):
        super(JsonPlist, self).__init__(**kwargs)
        self.list = list
        self.page_size = page_size
        self.sort_by = sort_by
        self.sort_type = sort_type
        self.start_index = start_index
        self.total_count = total_count


class JsonAtlasClassifications(JsonPlist):
    """REST serialization friendly list.

    :param list: An array of objects.
    :type list: list[object]
    :param page_size: The size of the page.
    :type page_size: int
    :param sort_by: The sorted by field.
    :type sort_by: str
    :param sort_type: to specify whether the result should be sorted? If yes, whether asc or desc.
     Possible values include: "NONE", "ASC", "DESC".
    :type sort_type: str or ~PurviewCatalog.models.JsonSortType
    :param start_index: The start index of the page.
    :type start_index: long
    :param total_count: The total count of items.
    :type total_count: long
    """

    _attribute_map = {
        'list': {'key': 'list', 'type': '[object]'},
        'page_size': {'key': 'pageSize', 'type': 'int'},
        'sort_by': {'key': 'sortBy', 'type': 'str'},
        'sort_type': {'key': 'sortType', 'type': 'str'},
        'start_index': {'key': 'startIndex', 'type': 'long'},
        'total_count': {'key': 'totalCount', 'type': 'long'},
    }

    def __init__(
        self,
        *,
        list: Optional[List[object]] = None,
        page_size: Optional[int] = None,
        sort_by: Optional[str] = None,
        sort_type: Optional[Union[str, "JsonSortType"]] = None,
        start_index: Optional[int] = None,
        total_count: Optional[int] = None,
        **kwargs
    ):
        super(JsonAtlasClassifications, self).__init__(list=list, page_size=page_size, sort_by=sort_by, sort_type=sort_type, start_index=start_index, total_count=total_count, **kwargs)


class JsonAtlasConstraintDef(msrest.serialization.Model):
    """class that captures details of a constraint.

    :param params: The parameters of the constraint definition.
    :type params: dict[str, object]
    :param type: The type of the constraint.
    :type type: str
    """

    _attribute_map = {
        'params': {'key': 'params', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        params: Optional[Dict[str, object]] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasConstraintDef, self).__init__(**kwargs)
        self.params = params
        self.type = type


class JsonAtlasEntityExtInfo(msrest.serialization.Model):
    """An instance of an entity along with extended info - like hive_table, hive_database.

    :param referred_entities: The referred entities.
    :type referred_entities: dict[str, ~PurviewCatalog.models.JsonAtlasEntity]
    """

    _attribute_map = {
        'referred_entities': {'key': 'referredEntities', 'type': '{JsonAtlasEntity}'},
    }

    def __init__(
        self,
        *,
        referred_entities: Optional[Dict[str, "JsonAtlasEntity"]] = None,
        **kwargs
    ):
        super(JsonAtlasEntityExtInfo, self).__init__(**kwargs)
        self.referred_entities = referred_entities


class JsonAtlasEntitiesWithExtInfo(JsonAtlasEntityExtInfo):
    """An instance of an entity along with extended info - like hive_table, hive_database.

    :param referred_entities: The referred entities.
    :type referred_entities: dict[str, ~PurviewCatalog.models.JsonAtlasEntity]
    :param entities: An array of entities.
    :type entities: list[~PurviewCatalog.models.JsonAtlasEntity]
    """

    _attribute_map = {
        'referred_entities': {'key': 'referredEntities', 'type': '{JsonAtlasEntity}'},
        'entities': {'key': 'entities', 'type': '[JsonAtlasEntity]'},
    }

    def __init__(
        self,
        *,
        referred_entities: Optional[Dict[str, "JsonAtlasEntity"]] = None,
        entities: Optional[List["JsonAtlasEntity"]] = None,
        **kwargs
    ):
        super(JsonAtlasEntitiesWithExtInfo, self).__init__(referred_entities=referred_entities, **kwargs)
        self.entities = entities


class JsonAtlasEntity(JsonAtlasStruct):
    """An instance of an entity - like hive_table, hive_database.

    :param attributes: The attributes of the struct.
    :type attributes: dict[str, object]
    :param type_name: The name of the type.
    :type type_name: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param guid: The GUID of the entity.
    :type guid: str
    :param home_id: The home ID of the entity.
    :type home_id: str
    :param meanings: An array of term assignment headers indicating the meanings of the entity.
    :type meanings: list[~PurviewCatalog.models.JsonAtlasTermAssignmentHeader]
    :param provenance_type: Used to record the provenance of an instance of an entity or
     relationship.
    :type provenance_type: float
    :param proxy: Determines if there's a proxy.
    :type proxy: bool
    :param relationship_attributes: The attributes of relationship.
    :type relationship_attributes: dict[str, object]
    :param status: Status of the entity - can be active or deleted. Deleted entities are not
     removed from Atlas store. Possible values include: "ACTIVE", "DELETED".
    :type status: str or ~PurviewCatalog.models.JsonStatus
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the entity.
    :type version: float
    :param source: indicate the source who create the classification detail.
    :type source: str
    :param source_details: more detail on source information.
    :type source_details: dict[str, object]
    :param contacts: The dictionary of contacts for terms. Key could be Expert or Owner.
    :type contacts: dict[str, ~PurviewCatalog.models.JsonContactBasic]
    """

    _attribute_map = {
        'attributes': {'key': 'attributes', 'type': '{object}'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'home_id': {'key': 'homeId', 'type': 'str'},
        'meanings': {'key': 'meanings', 'type': '[JsonAtlasTermAssignmentHeader]'},
        'provenance_type': {'key': 'provenanceType', 'type': 'float'},
        'proxy': {'key': 'proxy', 'type': 'bool'},
        'relationship_attributes': {'key': 'relationshipAttributes', 'type': '{object}'},
        'status': {'key': 'status', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'source': {'key': 'source', 'type': 'str'},
        'source_details': {'key': 'sourceDetails', 'type': '{object}'},
        'contacts': {'key': 'contacts', 'type': '{JsonContactBasic}'},
    }

    def __init__(
        self,
        *,
        attributes: Optional[Dict[str, object]] = None,
        type_name: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        guid: Optional[str] = None,
        home_id: Optional[str] = None,
        meanings: Optional[List["JsonAtlasTermAssignmentHeader"]] = None,
        provenance_type: Optional[float] = None,
        proxy: Optional[bool] = None,
        relationship_attributes: Optional[Dict[str, object]] = None,
        status: Optional[Union[str, "JsonStatus"]] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        source: Optional[str] = None,
        source_details: Optional[Dict[str, object]] = None,
        contacts: Optional[Dict[str, "JsonContactBasic"]] = None,
        **kwargs
    ):
        super(JsonAtlasEntity, self).__init__(attributes=attributes, type_name=type_name, last_modified_ts=last_modified_ts, **kwargs)
        self.classifications = classifications
        self.create_time = create_time
        self.created_by = created_by
        self.guid = guid
        self.home_id = home_id
        self.meanings = meanings
        self.provenance_type = provenance_type
        self.proxy = proxy
        self.relationship_attributes = relationship_attributes
        self.status = status
        self.update_time = update_time
        self.updated_by = updated_by
        self.version = version
        self.source = source
        self.source_details = source_details
        self.contacts = contacts


class JsonAtlasEntityDef(JsonAtlasStructDef):
    """class that captures details of a entity-type.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param attribute_defs: An array of attribute definitions.
    :type attribute_defs: list[~PurviewCatalog.models.JsonAtlasAttributeDef]
    :param sub_types: An array of sub types.
    :type sub_types: list[str]
    :param super_types: An array of super types.
    :type super_types: list[str]
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'attribute_defs': {'key': 'attributeDefs', 'type': '[JsonAtlasAttributeDef]'},
        'sub_types': {'key': 'subTypes', 'type': '[str]'},
        'super_types': {'key': 'superTypes', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        attribute_defs: Optional[List["JsonAtlasAttributeDef"]] = None,
        sub_types: Optional[List[str]] = None,
        super_types: Optional[List[str]] = None,
        **kwargs
    ):
        super(JsonAtlasEntityDef, self).__init__(category=category, create_time=create_time, created_by=created_by, date_formatter=date_formatter, description=description, guid=guid, name=name, options=options, service_type=service_type, type_version=type_version, update_time=update_time, updated_by=updated_by, version=version, last_modified_ts=last_modified_ts, attribute_defs=attribute_defs, **kwargs)
        self.sub_types = sub_types
        self.super_types = super_types


class JsonAtlasEntityHeader(JsonAtlasStruct):
    """An instance of an entity - like hive_table, hive_database.

    :param attributes: The attributes of the struct.
    :type attributes: dict[str, object]
    :param type_name: The name of the type.
    :type type_name: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param classification_names: An array of classification names.
    :type classification_names: list[str]
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param display_text: The display text.
    :type display_text: str
    :param guid: The GUID of the record.
    :type guid: str
    :param meaning_names: An array of meanings.
    :type meaning_names: list[str]
    :param meanings: An array of term assignment headers.
    :type meanings: list[~PurviewCatalog.models.JsonAtlasTermAssignmentHeader]
    :param status: Status of the entity - can be active or deleted. Deleted entities are not
     removed from Atlas store. Possible values include: "ACTIVE", "DELETED".
    :type status: str or ~PurviewCatalog.models.JsonStatus
    """

    _attribute_map = {
        'attributes': {'key': 'attributes', 'type': '{object}'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'classification_names': {'key': 'classificationNames', 'type': '[str]'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'display_text': {'key': 'displayText', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'meaning_names': {'key': 'meaningNames', 'type': '[str]'},
        'meanings': {'key': 'meanings', 'type': '[JsonAtlasTermAssignmentHeader]'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        attributes: Optional[Dict[str, object]] = None,
        type_name: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        classification_names: Optional[List[str]] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        display_text: Optional[str] = None,
        guid: Optional[str] = None,
        meaning_names: Optional[List[str]] = None,
        meanings: Optional[List["JsonAtlasTermAssignmentHeader"]] = None,
        status: Optional[Union[str, "JsonStatus"]] = None,
        **kwargs
    ):
        super(JsonAtlasEntityHeader, self).__init__(attributes=attributes, type_name=type_name, last_modified_ts=last_modified_ts, **kwargs)
        self.classification_names = classification_names
        self.classifications = classifications
        self.display_text = display_text
        self.guid = guid
        self.meaning_names = meaning_names
        self.meanings = meanings
        self.status = status


class JsonAtlasEntityHeaders(msrest.serialization.Model):
    """An instance of an entity header.

    :param guid_header_map: Dictionary of :code:`<json_AtlasEntityHeader>`.
    :type guid_header_map: dict[str, ~PurviewCatalog.models.JsonAtlasEntityHeader]
    """

    _attribute_map = {
        'guid_header_map': {'key': 'guidHeaderMap', 'type': '{JsonAtlasEntityHeader}'},
    }

    def __init__(
        self,
        *,
        guid_header_map: Optional[Dict[str, "JsonAtlasEntityHeader"]] = None,
        **kwargs
    ):
        super(JsonAtlasEntityHeaders, self).__init__(**kwargs)
        self.guid_header_map = guid_header_map


class JsonAtlasEntityWithExtInfo(JsonAtlasEntityExtInfo):
    """An instance of an entity along with extended info - like hive_table, hive_database.

    :param referred_entities: The referred entities.
    :type referred_entities: dict[str, ~PurviewCatalog.models.JsonAtlasEntity]
    :param entity: An instance of an entity - like hive_table, hive_database.
    :type entity: ~PurviewCatalog.models.JsonAtlasEntity
    """

    _attribute_map = {
        'referred_entities': {'key': 'referredEntities', 'type': '{JsonAtlasEntity}'},
        'entity': {'key': 'entity', 'type': 'JsonAtlasEntity'},
    }

    def __init__(
        self,
        *,
        referred_entities: Optional[Dict[str, "JsonAtlasEntity"]] = None,
        entity: Optional["JsonAtlasEntity"] = None,
        **kwargs
    ):
        super(JsonAtlasEntityWithExtInfo, self).__init__(referred_entities=referred_entities, **kwargs)
        self.entity = entity


class JsonAtlasEnumDef(JsonAtlasBaseTypeDef):
    """class that captures details of an enum-type.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param default_value: The default value.
    :type default_value: str
    :param element_defs: An array of enum element definitions.
    :type element_defs: list[~PurviewCatalog.models.JsonAtlasEnumElementDef]
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'default_value': {'key': 'defaultValue', 'type': 'str'},
        'element_defs': {'key': 'elementDefs', 'type': '[JsonAtlasEnumElementDef]'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        default_value: Optional[str] = None,
        element_defs: Optional[List["JsonAtlasEnumElementDef"]] = None,
        **kwargs
    ):
        super(JsonAtlasEnumDef, self).__init__(category=category, create_time=create_time, created_by=created_by, date_formatter=date_formatter, description=description, guid=guid, name=name, options=options, service_type=service_type, type_version=type_version, update_time=update_time, updated_by=updated_by, version=version, last_modified_ts=last_modified_ts, **kwargs)
        self.default_value = default_value
        self.element_defs = element_defs


class JsonAtlasEnumElementDef(msrest.serialization.Model):
    """class that captures details of an enum-element.

    :param description: The description of the enum element definition.
    :type description: str
    :param ordinal: The ordinal of the enum element definition.
    :type ordinal: float
    :param value: The value of the enum element definition.
    :type value: str
    """

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'ordinal': {'key': 'ordinal', 'type': 'float'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        ordinal: Optional[float] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasEnumElementDef, self).__init__(**kwargs)
        self.description = description
        self.ordinal = ordinal
        self.value = value


class JsonAtlasError(msrest.serialization.Model):
    """The atlas error response.

    :param error_code: Error code.
    :type error_code: str
    :param error_message: Error message.
    :type error_message: str
    """

    _attribute_map = {
        'error_code': {'key': 'errorCode', 'type': 'str'},
        'error_message': {'key': 'errorMessage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasError, self).__init__(**kwargs)
        self.error_code = error_code
        self.error_message = error_message


class JsonAtlasGlossaryBaseObject(JsonAtlasBaseModelObject):
    """The glossary base object.

    :param guid: The GUID of the object.
    :type guid: str
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param long_description: The long version description.
    :type long_description: str
    :param name: The name of the glossary object.
    :type name: str
    :param qualified_name: The qualified name of the glossary object.
    :type qualified_name: str
    :param short_description: The short version of description.
    :type short_description: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'long_description': {'key': 'longDescription', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'short_description': {'key': 'shortDescription', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        long_description: Optional[str] = None,
        name: Optional[str] = None,
        qualified_name: Optional[str] = None,
        short_description: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasGlossaryBaseObject, self).__init__(guid=guid, **kwargs)
        self.classifications = classifications
        self.long_description = long_description
        self.name = name
        self.qualified_name = qualified_name
        self.short_description = short_description
        self.last_modified_ts = last_modified_ts


class JsonAtlasGlossary(JsonAtlasGlossaryBaseObject):
    """The glossary object.

    :param guid: The GUID of the object.
    :type guid: str
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param long_description: The long version description.
    :type long_description: str
    :param name: The name of the glossary object.
    :type name: str
    :param qualified_name: The qualified name of the glossary object.
    :type qualified_name: str
    :param short_description: The short version of description.
    :type short_description: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param categories: An array of categories.
    :type categories: list[~PurviewCatalog.models.JsonAtlasRelatedCategoryHeader]
    :param language: The language of the glossary.
    :type language: str
    :param terms: An array of related term headers.
    :type terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param usage: The usage of the glossary.
    :type usage: str
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'long_description': {'key': 'longDescription', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'short_description': {'key': 'shortDescription', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'categories': {'key': 'categories', 'type': '[JsonAtlasRelatedCategoryHeader]'},
        'language': {'key': 'language', 'type': 'str'},
        'terms': {'key': 'terms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'usage': {'key': 'usage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        long_description: Optional[str] = None,
        name: Optional[str] = None,
        qualified_name: Optional[str] = None,
        short_description: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        categories: Optional[List["JsonAtlasRelatedCategoryHeader"]] = None,
        language: Optional[str] = None,
        terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        usage: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasGlossary, self).__init__(guid=guid, classifications=classifications, long_description=long_description, name=name, qualified_name=qualified_name, short_description=short_description, last_modified_ts=last_modified_ts, **kwargs)
        self.categories = categories
        self.language = language
        self.terms = terms
        self.usage = usage


class JsonAtlasGlossaryCategory(JsonAtlasGlossaryBaseObject):
    """The glossary category.

    :param guid: The GUID of the object.
    :type guid: str
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param long_description: The long version description.
    :type long_description: str
    :param name: The name of the glossary object.
    :type name: str
    :param qualified_name: The qualified name of the glossary object.
    :type qualified_name: str
    :param short_description: The short version of description.
    :type short_description: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param anchor: The glossary header with basic information.
    :type anchor: ~PurviewCatalog.models.JsonAtlasGlossaryHeader
    :param children_categories: An array of children categories.
    :type children_categories: list[~PurviewCatalog.models.JsonAtlasRelatedCategoryHeader]
    :param parent_category: The header of the related category.
    :type parent_category: ~PurviewCatalog.models.JsonAtlasRelatedCategoryHeader
    :param terms: An array of related term headers.
    :type terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'long_description': {'key': 'longDescription', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'short_description': {'key': 'shortDescription', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'anchor': {'key': 'anchor', 'type': 'JsonAtlasGlossaryHeader'},
        'children_categories': {'key': 'childrenCategories', 'type': '[JsonAtlasRelatedCategoryHeader]'},
        'parent_category': {'key': 'parentCategory', 'type': 'JsonAtlasRelatedCategoryHeader'},
        'terms': {'key': 'terms', 'type': '[JsonAtlasRelatedTermHeader]'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        long_description: Optional[str] = None,
        name: Optional[str] = None,
        qualified_name: Optional[str] = None,
        short_description: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        anchor: Optional["JsonAtlasGlossaryHeader"] = None,
        children_categories: Optional[List["JsonAtlasRelatedCategoryHeader"]] = None,
        parent_category: Optional["JsonAtlasRelatedCategoryHeader"] = None,
        terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        **kwargs
    ):
        super(JsonAtlasGlossaryCategory, self).__init__(guid=guid, classifications=classifications, long_description=long_description, name=name, qualified_name=qualified_name, short_description=short_description, last_modified_ts=last_modified_ts, **kwargs)
        self.anchor = anchor
        self.children_categories = children_categories
        self.parent_category = parent_category
        self.terms = terms


class JsonAtlasGlossaryExtInfo(JsonAtlasGlossary):
    """The extended information of glossary.

    :param guid: The GUID of the object.
    :type guid: str
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param long_description: The long version description.
    :type long_description: str
    :param name: The name of the glossary object.
    :type name: str
    :param qualified_name: The qualified name of the glossary object.
    :type qualified_name: str
    :param short_description: The short version of description.
    :type short_description: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param categories: An array of categories.
    :type categories: list[~PurviewCatalog.models.JsonAtlasRelatedCategoryHeader]
    :param language: The language of the glossary.
    :type language: str
    :param terms: An array of related term headers.
    :type terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param usage: The usage of the glossary.
    :type usage: str
    :param category_info: The glossary category information.
    :type category_info: dict[str, ~PurviewCatalog.models.JsonAtlasGlossaryCategory]
    :param term_info: The glossary term information.
    :type term_info: dict[str, ~PurviewCatalog.models.JsonAtlasGlossaryTerm]
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'long_description': {'key': 'longDescription', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'short_description': {'key': 'shortDescription', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'categories': {'key': 'categories', 'type': '[JsonAtlasRelatedCategoryHeader]'},
        'language': {'key': 'language', 'type': 'str'},
        'terms': {'key': 'terms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'usage': {'key': 'usage', 'type': 'str'},
        'category_info': {'key': 'categoryInfo', 'type': '{JsonAtlasGlossaryCategory}'},
        'term_info': {'key': 'termInfo', 'type': '{JsonAtlasGlossaryTerm}'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        long_description: Optional[str] = None,
        name: Optional[str] = None,
        qualified_name: Optional[str] = None,
        short_description: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        categories: Optional[List["JsonAtlasRelatedCategoryHeader"]] = None,
        language: Optional[str] = None,
        terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        usage: Optional[str] = None,
        category_info: Optional[Dict[str, "JsonAtlasGlossaryCategory"]] = None,
        term_info: Optional[Dict[str, "JsonAtlasGlossaryTerm"]] = None,
        **kwargs
    ):
        super(JsonAtlasGlossaryExtInfo, self).__init__(guid=guid, classifications=classifications, long_description=long_description, name=name, qualified_name=qualified_name, short_description=short_description, last_modified_ts=last_modified_ts, categories=categories, language=language, terms=terms, usage=usage, **kwargs)
        self.category_info = category_info
        self.term_info = term_info


class JsonAtlasGlossaryHeader(msrest.serialization.Model):
    """The glossary header with basic information.

    :param display_text: The display text.
    :type display_text: str
    :param glossary_guid: The GUID of the glossary.
    :type glossary_guid: str
    :param relation_guid: The GUID of the relationship.
    :type relation_guid: str
    """

    _attribute_map = {
        'display_text': {'key': 'displayText', 'type': 'str'},
        'glossary_guid': {'key': 'glossaryGuid', 'type': 'str'},
        'relation_guid': {'key': 'relationGuid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        display_text: Optional[str] = None,
        glossary_guid: Optional[str] = None,
        relation_guid: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasGlossaryHeader, self).__init__(**kwargs)
        self.display_text = display_text
        self.glossary_guid = glossary_guid
        self.relation_guid = relation_guid


class JsonAtlasGlossaryTerm(JsonAtlasGlossaryBaseObject):
    """The glossary term.

    :param guid: The GUID of the object.
    :type guid: str
    :param classifications: An array of classifications.
    :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param long_description: The long version description.
    :type long_description: str
    :param name: The name of the glossary object.
    :type name: str
    :param qualified_name: The qualified name of the glossary object.
    :type qualified_name: str
    :param short_description: The short version of description.
    :type short_description: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param abbreviation: The abbreviation of the term.
    :type abbreviation: str
    :param anchor: The glossary header with basic information.
    :type anchor: ~PurviewCatalog.models.JsonAtlasGlossaryHeader
    :param antonyms: An array of related term headers as antonyms.
    :type antonyms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param status: Status of the AtlasGlossaryTerm. Possible values include: "DRAFT", "APPROVED",
     "ALERT", "EXPIRED".
    :type status: str or ~PurviewCatalog.models.JsonTermStatus
    :param resources: An array of resource link for term.
    :type resources: list[~PurviewCatalog.models.JsonResourceLink]
    :param contacts: The dictionary of contacts for terms. Key could be Expert or Steward.
    :type contacts: dict[str, ~PurviewCatalog.models.JsonContactBasic]
    :param attributes: The custom attributes of the term, which is map<string,map<string,object>>.
     The key of the first layer map is term template name.
    :type attributes: dict[str, dict[str, object]]
    :param assigned_entities: An array of related object IDs.
    :type assigned_entities: list[~PurviewCatalog.models.JsonAtlasRelatedObjectId]
    :param categories: An array of term categorization headers.
    :type categories: list[~PurviewCatalog.models.JsonAtlasTermCategorizationHeader]
    :param classifies: An array of related term headers.
    :type classifies: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param examples: An array of examples.
    :type examples: list[str]
    :param is_a: An array of related term headers indicating the is-a relationship.
    :type is_a: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param preferred_terms: An array of preferred related term headers.
    :type preferred_terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param preferred_to_terms: An array of related term headers that are preferred to.
    :type preferred_to_terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param replaced_by: An array of related term headers that are replaced by.
    :type replaced_by: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param replacement_terms: An array of related term headers for replacement.
    :type replacement_terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param see_also: An array of related term headers for see also.
    :type see_also: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param synonyms: An array of related term headers as synonyms.
    :type synonyms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param translated_terms: An array of translated related term headers.
    :type translated_terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param translation_terms: An array of related term headers for translation.
    :type translation_terms: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param usage: The usage of the term.
    :type usage: str
    :param valid_values: An array of related term headers as valid values.
    :type valid_values: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    :param valid_values_for: An array of related term headers as valid values for other records.
    :type valid_values_for: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'classifications': {'key': 'classifications', 'type': '[JsonAtlasClassification]'},
        'long_description': {'key': 'longDescription', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'short_description': {'key': 'shortDescription', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'abbreviation': {'key': 'abbreviation', 'type': 'str'},
        'anchor': {'key': 'anchor', 'type': 'JsonAtlasGlossaryHeader'},
        'antonyms': {'key': 'antonyms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'resources': {'key': 'resources', 'type': '[JsonResourceLink]'},
        'contacts': {'key': 'contacts', 'type': '{JsonContactBasic}'},
        'attributes': {'key': 'attributes', 'type': '{{object}}'},
        'assigned_entities': {'key': 'assignedEntities', 'type': '[JsonAtlasRelatedObjectId]'},
        'categories': {'key': 'categories', 'type': '[JsonAtlasTermCategorizationHeader]'},
        'classifies': {'key': 'classifies', 'type': '[JsonAtlasRelatedTermHeader]'},
        'examples': {'key': 'examples', 'type': '[str]'},
        'is_a': {'key': 'isA', 'type': '[JsonAtlasRelatedTermHeader]'},
        'preferred_terms': {'key': 'preferredTerms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'preferred_to_terms': {'key': 'preferredToTerms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'replaced_by': {'key': 'replacedBy', 'type': '[JsonAtlasRelatedTermHeader]'},
        'replacement_terms': {'key': 'replacementTerms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'see_also': {'key': 'seeAlso', 'type': '[JsonAtlasRelatedTermHeader]'},
        'synonyms': {'key': 'synonyms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'translated_terms': {'key': 'translatedTerms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'translation_terms': {'key': 'translationTerms', 'type': '[JsonAtlasRelatedTermHeader]'},
        'usage': {'key': 'usage', 'type': 'str'},
        'valid_values': {'key': 'validValues', 'type': '[JsonAtlasRelatedTermHeader]'},
        'valid_values_for': {'key': 'validValuesFor', 'type': '[JsonAtlasRelatedTermHeader]'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        classifications: Optional[List["JsonAtlasClassification"]] = None,
        long_description: Optional[str] = None,
        name: Optional[str] = None,
        qualified_name: Optional[str] = None,
        short_description: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        abbreviation: Optional[str] = None,
        anchor: Optional["JsonAtlasGlossaryHeader"] = None,
        antonyms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        status: Optional[Union[str, "JsonTermStatus"]] = None,
        resources: Optional[List["JsonResourceLink"]] = None,
        contacts: Optional[Dict[str, "JsonContactBasic"]] = None,
        attributes: Optional[Dict[str, Dict[str, object]]] = None,
        assigned_entities: Optional[List["JsonAtlasRelatedObjectId"]] = None,
        categories: Optional[List["JsonAtlasTermCategorizationHeader"]] = None,
        classifies: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        examples: Optional[List[str]] = None,
        is_a: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        preferred_terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        preferred_to_terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        replaced_by: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        replacement_terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        see_also: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        synonyms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        translated_terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        translation_terms: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        usage: Optional[str] = None,
        valid_values: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        valid_values_for: Optional[List["JsonAtlasRelatedTermHeader"]] = None,
        **kwargs
    ):
        super(JsonAtlasGlossaryTerm, self).__init__(guid=guid, classifications=classifications, long_description=long_description, name=name, qualified_name=qualified_name, short_description=short_description, last_modified_ts=last_modified_ts, **kwargs)
        self.abbreviation = abbreviation
        self.anchor = anchor
        self.antonyms = antonyms
        self.create_time = create_time
        self.created_by = created_by
        self.update_time = update_time
        self.updated_by = updated_by
        self.status = status
        self.resources = resources
        self.contacts = contacts
        self.attributes = attributes
        self.assigned_entities = assigned_entities
        self.categories = categories
        self.classifies = classifies
        self.examples = examples
        self.is_a = is_a
        self.preferred_terms = preferred_terms
        self.preferred_to_terms = preferred_to_terms
        self.replaced_by = replaced_by
        self.replacement_terms = replacement_terms
        self.see_also = see_also
        self.synonyms = synonyms
        self.translated_terms = translated_terms
        self.translation_terms = translation_terms
        self.usage = usage
        self.valid_values = valid_values
        self.valid_values_for = valid_values_for


class JsonAtlasLineageInfo(msrest.serialization.Model):
    """The lineage information.

    :param base_entity_guid: The GUID of the base entity.
    :type base_entity_guid: str
    :param guid_entity_map: The GUID entity map.
    :type guid_entity_map: dict[str, ~PurviewCatalog.models.JsonAtlasEntityHeader]
    :param width_counts: The entity count in specific direction.
    :type width_counts: dict[str, dict[str, object]]
    :param lineage_depth: The depth of lineage.
    :type lineage_depth: int
    :param lineage_width: The width of lineage.
    :type lineage_width: int
    :param include_parent: True to return the parent of the base entity.
    :type include_parent: bool
    :param children_count: The number of children node.
    :type children_count: int
    :param lineage_direction: The enum of lineage direction. Possible values include: "INPUT",
     "OUTPUT", "BOTH".
    :type lineage_direction: str or ~PurviewCatalog.models.JsonLineageDirection
    :param parent_relations: An array of parentRelations relations.
    :type parent_relations: list[~PurviewCatalog.models.JsonParentRelation]
    :param relations: An array of lineage relations.
    :type relations: list[~PurviewCatalog.models.JsonLineageRelation]
    """

    _attribute_map = {
        'base_entity_guid': {'key': 'baseEntityGuid', 'type': 'str'},
        'guid_entity_map': {'key': 'guidEntityMap', 'type': '{JsonAtlasEntityHeader}'},
        'width_counts': {'key': 'widthCounts', 'type': '{{object}}'},
        'lineage_depth': {'key': 'lineageDepth', 'type': 'int'},
        'lineage_width': {'key': 'lineageWidth', 'type': 'int'},
        'include_parent': {'key': 'includeParent', 'type': 'bool'},
        'children_count': {'key': 'childrenCount', 'type': 'int'},
        'lineage_direction': {'key': 'lineageDirection', 'type': 'str'},
        'parent_relations': {'key': 'parentRelations', 'type': '[JsonParentRelation]'},
        'relations': {'key': 'relations', 'type': '[JsonLineageRelation]'},
    }

    def __init__(
        self,
        *,
        base_entity_guid: Optional[str] = None,
        guid_entity_map: Optional[Dict[str, "JsonAtlasEntityHeader"]] = None,
        width_counts: Optional[Dict[str, Dict[str, object]]] = None,
        lineage_depth: Optional[int] = None,
        lineage_width: Optional[int] = None,
        include_parent: Optional[bool] = None,
        children_count: Optional[int] = None,
        lineage_direction: Optional[Union[str, "JsonLineageDirection"]] = None,
        parent_relations: Optional[List["JsonParentRelation"]] = None,
        relations: Optional[List["JsonLineageRelation"]] = None,
        **kwargs
    ):
        super(JsonAtlasLineageInfo, self).__init__(**kwargs)
        self.base_entity_guid = base_entity_guid
        self.guid_entity_map = guid_entity_map
        self.width_counts = width_counts
        self.lineage_depth = lineage_depth
        self.lineage_width = lineage_width
        self.include_parent = include_parent
        self.children_count = children_count
        self.lineage_direction = lineage_direction
        self.parent_relations = parent_relations
        self.relations = relations


class JsonAtlasObjectId(msrest.serialization.Model):
    """Reference to an object-instance of an Atlas type - like entity.

    :param guid: The GUID of the object.
    :type guid: str
    :param type_name: The name of the type.
    :type type_name: str
    :param unique_attributes: The unique attributes of the object.
    :type unique_attributes: dict[str, object]
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'unique_attributes': {'key': 'uniqueAttributes', 'type': '{object}'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        type_name: Optional[str] = None,
        unique_attributes: Optional[Dict[str, object]] = None,
        **kwargs
    ):
        super(JsonAtlasObjectId, self).__init__(**kwargs)
        self.guid = guid
        self.type_name = type_name
        self.unique_attributes = unique_attributes


class JsonAtlasRelatedCategoryHeader(msrest.serialization.Model):
    """The header of the related category.

    :param category_guid: The GUID of the category.
    :type category_guid: str
    :param description: The description of the category header.
    :type description: str
    :param display_text: The display text.
    :type display_text: str
    :param parent_category_guid: The GUID of the parent category.
    :type parent_category_guid: str
    :param relation_guid: The GUID of the relationship.
    :type relation_guid: str
    """

    _attribute_map = {
        'category_guid': {'key': 'categoryGuid', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'display_text': {'key': 'displayText', 'type': 'str'},
        'parent_category_guid': {'key': 'parentCategoryGuid', 'type': 'str'},
        'relation_guid': {'key': 'relationGuid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        category_guid: Optional[str] = None,
        description: Optional[str] = None,
        display_text: Optional[str] = None,
        parent_category_guid: Optional[str] = None,
        relation_guid: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasRelatedCategoryHeader, self).__init__(**kwargs)
        self.category_guid = category_guid
        self.description = description
        self.display_text = display_text
        self.parent_category_guid = parent_category_guid
        self.relation_guid = relation_guid


class JsonAtlasRelatedObjectId(JsonAtlasObjectId):
    """Reference to an object-instance of AtlasEntity type used in relationship attribute values.

    :param guid: The GUID of the object.
    :type guid: str
    :param type_name: The name of the type.
    :type type_name: str
    :param unique_attributes: The unique attributes of the object.
    :type unique_attributes: dict[str, object]
    :param display_text: The display text.
    :type display_text: str
    :param entity_status: Status of the entity - can be active or deleted. Deleted entities are not
     removed from Atlas store. Possible values include: "ACTIVE", "DELETED".
    :type entity_status: str or ~PurviewCatalog.models.JsonStatus
    :param relationship_attributes: Captures details of struct contents. Not instantiated directly,
     used only via AtlasEntity, AtlasClassification.
    :type relationship_attributes: ~PurviewCatalog.models.JsonAtlasStruct
    :param relationship_guid: The GUID of the relationship.
    :type relationship_guid: str
    :param relationship_status: The enum of relationship status. Possible values include: "ACTIVE",
     "DELETED".
    :type relationship_status: str or ~PurviewCatalog.models.JsonStatusAtlasRelationship
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'unique_attributes': {'key': 'uniqueAttributes', 'type': '{object}'},
        'display_text': {'key': 'displayText', 'type': 'str'},
        'entity_status': {'key': 'entityStatus', 'type': 'str'},
        'relationship_attributes': {'key': 'relationshipAttributes', 'type': 'JsonAtlasStruct'},
        'relationship_guid': {'key': 'relationshipGuid', 'type': 'str'},
        'relationship_status': {'key': 'relationshipStatus', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        type_name: Optional[str] = None,
        unique_attributes: Optional[Dict[str, object]] = None,
        display_text: Optional[str] = None,
        entity_status: Optional[Union[str, "JsonStatus"]] = None,
        relationship_attributes: Optional["JsonAtlasStruct"] = None,
        relationship_guid: Optional[str] = None,
        relationship_status: Optional[Union[str, "JsonStatusAtlasRelationship"]] = None,
        **kwargs
    ):
        super(JsonAtlasRelatedObjectId, self).__init__(guid=guid, type_name=type_name, unique_attributes=unique_attributes, **kwargs)
        self.display_text = display_text
        self.entity_status = entity_status
        self.relationship_attributes = relationship_attributes
        self.relationship_guid = relationship_guid
        self.relationship_status = relationship_status


class JsonAtlasRelatedTermHeader(msrest.serialization.Model):
    """The header of the related term.

    :param description: The description of the related term.
    :type description: str
    :param display_text: The display text.
    :type display_text: str
    :param expression: The expression of the term.
    :type expression: str
    :param relation_guid: The GUID of the relationship.
    :type relation_guid: str
    :param source: The source of the term.
    :type source: str
    :param status: The status of term relationship. Possible values include: "DRAFT", "ACTIVE",
     "DEPRECATED", "OBSOLETE", "OTHER".
    :type status: str or ~PurviewCatalog.models.JsonAtlasTermRelationshipStatus
    :param steward: The steward of the term.
    :type steward: str
    :param term_guid: The GUID of the term.
    :type term_guid: str
    """

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'display_text': {'key': 'displayText', 'type': 'str'},
        'expression': {'key': 'expression', 'type': 'str'},
        'relation_guid': {'key': 'relationGuid', 'type': 'str'},
        'source': {'key': 'source', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'steward': {'key': 'steward', 'type': 'str'},
        'term_guid': {'key': 'termGuid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        display_text: Optional[str] = None,
        expression: Optional[str] = None,
        relation_guid: Optional[str] = None,
        source: Optional[str] = None,
        status: Optional[Union[str, "JsonAtlasTermRelationshipStatus"]] = None,
        steward: Optional[str] = None,
        term_guid: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasRelatedTermHeader, self).__init__(**kwargs)
        self.description = description
        self.display_text = display_text
        self.expression = expression
        self.relation_guid = relation_guid
        self.source = source
        self.status = status
        self.steward = steward
        self.term_guid = term_guid


class JsonAtlasRelationship(JsonAtlasStruct):
    """Atlas relationship instance.

    :param attributes: The attributes of the struct.
    :type attributes: dict[str, object]
    :param type_name: The name of the type.
    :type type_name: str
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param blocked_propagated_classifications: An array of blocked propagated classifications.
    :type blocked_propagated_classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param end1: Reference to an object-instance of an Atlas type - like entity.
    :type end1: ~PurviewCatalog.models.JsonAtlasObjectId
    :param end2: Reference to an object-instance of an Atlas type - like entity.
    :type end2: ~PurviewCatalog.models.JsonAtlasObjectId
    :param guid: The GUID of the relationship.
    :type guid: str
    :param home_id: The home ID of the relationship.
    :type home_id: str
    :param label: The label of the relationship.
    :type label: str
    :param propagate_tags: PropagateTags indicates whether tags should propagate across the
     relationship instance.
    
     :code:`<p>`
     Tags can propagate:
    
     :code:`<p>`
     NONE - not at all :code:`<br>`
     ONE_TO_TWO - from end 1 to 2 :code:`<br>`
     TWO_TO_ONE - from end 2 to 1  :code:`<br>`
     BOTH - both ways
    
     :code:`<p>`
     Care needs to be taken when specifying. The use cases we are aware of where this flag is
     useful:
    
     :code:`<p>`
    
    
     * propagating confidentiality classifications from a table to columns - ONE_TO_TWO could be
     used here :code:`<br>`
     * propagating classifications around Glossary synonyms - BOTH could be used here.
       :code:`<p>`
       There is an expectation that further enhancements will allow more granular control of tag
     propagation and will
       address how to resolve conflicts. Possible values include: "NONE", "ONE_TO_TWO",
     "TWO_TO_ONE", "BOTH".
    :type propagate_tags: str or ~PurviewCatalog.models.JsonPropagateTags
    :param propagated_classifications: An array of propagated classifications.
    :type propagated_classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
    :param provenance_type: Used to record the provenance of an instance of an entity or
     relationship.
    :type provenance_type: float
    :param status: The enum of relationship status. Possible values include: "ACTIVE", "DELETED".
    :type status: str or ~PurviewCatalog.models.JsonStatusAtlasRelationship
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the relationship.
    :type version: float
    """

    _attribute_map = {
        'attributes': {'key': 'attributes', 'type': '{object}'},
        'type_name': {'key': 'typeName', 'type': 'str'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'blocked_propagated_classifications': {'key': 'blockedPropagatedClassifications', 'type': '[JsonAtlasClassification]'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'end1': {'key': 'end1', 'type': 'JsonAtlasObjectId'},
        'end2': {'key': 'end2', 'type': 'JsonAtlasObjectId'},
        'guid': {'key': 'guid', 'type': 'str'},
        'home_id': {'key': 'homeId', 'type': 'str'},
        'label': {'key': 'label', 'type': 'str'},
        'propagate_tags': {'key': 'propagateTags', 'type': 'str'},
        'propagated_classifications': {'key': 'propagatedClassifications', 'type': '[JsonAtlasClassification]'},
        'provenance_type': {'key': 'provenanceType', 'type': 'float'},
        'status': {'key': 'status', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        attributes: Optional[Dict[str, object]] = None,
        type_name: Optional[str] = None,
        last_modified_ts: Optional[str] = None,
        blocked_propagated_classifications: Optional[List["JsonAtlasClassification"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        end1: Optional["JsonAtlasObjectId"] = None,
        end2: Optional["JsonAtlasObjectId"] = None,
        guid: Optional[str] = None,
        home_id: Optional[str] = None,
        label: Optional[str] = None,
        propagate_tags: Optional[Union[str, "JsonPropagateTags"]] = None,
        propagated_classifications: Optional[List["JsonAtlasClassification"]] = None,
        provenance_type: Optional[float] = None,
        status: Optional[Union[str, "JsonStatusAtlasRelationship"]] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        **kwargs
    ):
        super(JsonAtlasRelationship, self).__init__(attributes=attributes, type_name=type_name, last_modified_ts=last_modified_ts, **kwargs)
        self.blocked_propagated_classifications = blocked_propagated_classifications
        self.create_time = create_time
        self.created_by = created_by
        self.end1 = end1
        self.end2 = end2
        self.guid = guid
        self.home_id = home_id
        self.label = label
        self.propagate_tags = propagate_tags
        self.propagated_classifications = propagated_classifications
        self.provenance_type = provenance_type
        self.status = status
        self.update_time = update_time
        self.updated_by = updated_by
        self.version = version


class JsonAtlasRelationshipDef(JsonAtlasStructDef):
    """AtlasRelationshipDef is a TypeDef that defines a relationship.

:code:`<p>`
As with other typeDefs the AtlasRelationshipDef has a name. Once created the RelationshipDef has a guid.
The name and the guid are the 2 ways that the RelationshipDef is identified.

:code:`<p>`
RelationshipDefs have 2 ends, each of which specify cardinality, an EntityDef type name and name and optionally
whether the end is a container.

:code:`<p>`
RelationshipDefs can have AttributeDefs - though only primitive types are allowed. :code:`<br>`
RelationshipDefs have a relationshipCategory specifying the UML type of relationship required :code:`<br>`
RelationshipDefs also have a PropogateTag - indicating which way tags could flow over the relationships.

:code:`<p>`
The way EntityDefs and RelationshipDefs are intended to be used is that EntityDefs will define AttributeDefs these AttributeDefs
will not specify an EntityDef type name as their types.

:code:`<p>`
RelationshipDefs introduce new atributes to the entity instances. For example

:code:`<p>`
EntityDef A might have attributes attr1,attr2,attr3 :code:`<br>`
EntityDef B might have attributes attr4,attr5,attr6 :code:`<br>`
RelationshipDef AtoB might define 2 ends :code:`<br>`


.. raw:: html

   <pre>
      end1:  type A, name attr7
      end2:  type B, name attr8  </pre>


:code:`<p>`
When an instance of EntityDef A is created, it will have attributes attr1,attr2,attr3,attr7 :code:`<br>`
When an instance of EntityDef B is created, it will have attributes attr4,attr5,attr6,attr8

:code:`<p>`
In this way relationshipDefs can be authored separately from entityDefs and can inject relationship attributes into
the entity instances.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param attribute_defs: An array of attribute definitions.
    :type attribute_defs: list[~PurviewCatalog.models.JsonAtlasAttributeDef]
    :param end_def1: The relationshipEndDef represents an end of the relationship. The end of the
     relationship is defined by a type, an
     attribute name, cardinality and whether it  is the container end of the relationship.
    :type end_def1: ~PurviewCatalog.models.JsonAtlasRelationshipEndDef
    :param end_def2: The relationshipEndDef represents an end of the relationship. The end of the
     relationship is defined by a type, an
     attribute name, cardinality and whether it  is the container end of the relationship.
    :type end_def2: ~PurviewCatalog.models.JsonAtlasRelationshipEndDef
    :param propagate_tags: PropagateTags indicates whether tags should propagate across the
     relationship instance.
    
     :code:`<p>`
     Tags can propagate:
    
     :code:`<p>`
     NONE - not at all :code:`<br>`
     ONE_TO_TWO - from end 1 to 2 :code:`<br>`
     TWO_TO_ONE - from end 2 to 1  :code:`<br>`
     BOTH - both ways
    
     :code:`<p>`
     Care needs to be taken when specifying. The use cases we are aware of where this flag is
     useful:
    
     :code:`<p>`
    
    
     * propagating confidentiality classifications from a table to columns - ONE_TO_TWO could be
     used here :code:`<br>`
     * propagating classifications around Glossary synonyms - BOTH could be used here.
       :code:`<p>`
       There is an expectation that further enhancements will allow more granular control of tag
     propagation and will
       address how to resolve conflicts. Possible values include: "NONE", "ONE_TO_TWO",
     "TWO_TO_ONE", "BOTH".
    :type propagate_tags: str or ~PurviewCatalog.models.JsonPropagateTags
    :param relationship_category: The Relationship category determines the style of relationship
     around containment and lifecycle.
     UML terminology is used for the values.
    
     :code:`<p>`
     ASSOCIATION is a relationship with no containment. :code:`<br>`
     COMPOSITION and AGGREGATION are containment relationships.
    
     :code:`<p>`
     The difference being in the lifecycles of the container and its children. In the COMPOSITION
     case,
     the children cannot exist without the container. For AGGREGATION, the life cycles
     of the container and children are totally independant. Possible values include: "ASSOCIATION",
     "AGGREGATION", "COMPOSITION".
    :type relationship_category: str or ~PurviewCatalog.models.JsonRelationshipCategory
    :param relationship_label: The label of the relationship.
    :type relationship_label: str
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'attribute_defs': {'key': 'attributeDefs', 'type': '[JsonAtlasAttributeDef]'},
        'end_def1': {'key': 'endDef1', 'type': 'JsonAtlasRelationshipEndDef'},
        'end_def2': {'key': 'endDef2', 'type': 'JsonAtlasRelationshipEndDef'},
        'propagate_tags': {'key': 'propagateTags', 'type': 'str'},
        'relationship_category': {'key': 'relationshipCategory', 'type': 'str'},
        'relationship_label': {'key': 'relationshipLabel', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        attribute_defs: Optional[List["JsonAtlasAttributeDef"]] = None,
        end_def1: Optional["JsonAtlasRelationshipEndDef"] = None,
        end_def2: Optional["JsonAtlasRelationshipEndDef"] = None,
        propagate_tags: Optional[Union[str, "JsonPropagateTags"]] = None,
        relationship_category: Optional[Union[str, "JsonRelationshipCategory"]] = None,
        relationship_label: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasRelationshipDef, self).__init__(category=category, create_time=create_time, created_by=created_by, date_formatter=date_formatter, description=description, guid=guid, name=name, options=options, service_type=service_type, type_version=type_version, update_time=update_time, updated_by=updated_by, version=version, last_modified_ts=last_modified_ts, attribute_defs=attribute_defs, **kwargs)
        self.end_def1 = end_def1
        self.end_def2 = end_def2
        self.propagate_tags = propagate_tags
        self.relationship_category = relationship_category
        self.relationship_label = relationship_label


class JsonAtlasRelationshipEndDef(msrest.serialization.Model):
    """The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.

    :param cardinality: single-valued attribute or multi-valued attribute. Possible values include:
     "SINGLE", "LIST", "SET".
    :type cardinality: str or ~PurviewCatalog.models.JsonCardinality
    :param description: The description of the relationship end definition.
    :type description: str
    :param is_container: Determines if it is container.
    :type is_container: bool
    :param is_legacy_attribute: Determines if it is a legacy attribute.
    :type is_legacy_attribute: bool
    :param name: The name of the relationship end definition.
    :type name: str
    :param type: The type of the relationship end.
    :type type: str
    """

    _attribute_map = {
        'cardinality': {'key': 'cardinality', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'is_container': {'key': 'isContainer', 'type': 'bool'},
        'is_legacy_attribute': {'key': 'isLegacyAttribute', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        cardinality: Optional[Union[str, "JsonCardinality"]] = None,
        description: Optional[str] = None,
        is_container: Optional[bool] = None,
        is_legacy_attribute: Optional[bool] = None,
        name: Optional[str] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasRelationshipEndDef, self).__init__(**kwargs)
        self.cardinality = cardinality
        self.description = description
        self.is_container = is_container
        self.is_legacy_attribute = is_legacy_attribute
        self.name = name
        self.type = type


class JsonAtlasRelationshipWithExtInfo(msrest.serialization.Model):
    """The relationship with extended information.

    :param referred_entities: The referred entity header.
    :type referred_entities: dict[str, ~PurviewCatalog.models.JsonAtlasEntityHeader]
    :param relationship: Atlas relationship instance.
    :type relationship: ~PurviewCatalog.models.JsonAtlasRelationship
    """

    _attribute_map = {
        'referred_entities': {'key': 'referredEntities', 'type': '{JsonAtlasEntityHeader}'},
        'relationship': {'key': 'relationship', 'type': 'JsonAtlasRelationship'},
    }

    def __init__(
        self,
        *,
        referred_entities: Optional[Dict[str, "JsonAtlasEntityHeader"]] = None,
        relationship: Optional["JsonAtlasRelationship"] = None,
        **kwargs
    ):
        super(JsonAtlasRelationshipWithExtInfo, self).__init__(**kwargs)
        self.referred_entities = referred_entities
        self.relationship = relationship


class JsonAtlasTermAssignmentHeader(msrest.serialization.Model):
    """The header for term assignment.

    :param confidence: The confidence of the term assignment.
    :type confidence: int
    :param created_by: The user who created the record.
    :type created_by: str
    :param description: The description of the term assignment.
    :type description: str
    :param display_text: The display text.
    :type display_text: str
    :param expression: The expression of the term assignment.
    :type expression: str
    :param relation_guid: The GUID of the relationship.
    :type relation_guid: str
    :param source: The source of the term.
    :type source: str
    :param status: The status of terms assignment. Possible values include: "DISCOVERED",
     "PROPOSED", "IMPORTED", "VALIDATED", "DEPRECATED", "OBSOLETE", "OTHER".
    :type status: str or ~PurviewCatalog.models.JsonAtlasTermAssignmentStatus
    :param steward: The steward of the term.
    :type steward: str
    :param term_guid: The GUID of the term.
    :type term_guid: str
    """

    _attribute_map = {
        'confidence': {'key': 'confidence', 'type': 'int'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'display_text': {'key': 'displayText', 'type': 'str'},
        'expression': {'key': 'expression', 'type': 'str'},
        'relation_guid': {'key': 'relationGuid', 'type': 'str'},
        'source': {'key': 'source', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'steward': {'key': 'steward', 'type': 'str'},
        'term_guid': {'key': 'termGuid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        confidence: Optional[int] = None,
        created_by: Optional[str] = None,
        description: Optional[str] = None,
        display_text: Optional[str] = None,
        expression: Optional[str] = None,
        relation_guid: Optional[str] = None,
        source: Optional[str] = None,
        status: Optional[Union[str, "JsonAtlasTermAssignmentStatus"]] = None,
        steward: Optional[str] = None,
        term_guid: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasTermAssignmentHeader, self).__init__(**kwargs)
        self.confidence = confidence
        self.created_by = created_by
        self.description = description
        self.display_text = display_text
        self.expression = expression
        self.relation_guid = relation_guid
        self.source = source
        self.status = status
        self.steward = steward
        self.term_guid = term_guid


class JsonAtlasTermCategorizationHeader(msrest.serialization.Model):
    """The basic information for term categorization.

    :param category_guid: The GUID of the category.
    :type category_guid: str
    :param description: The description of the record.
    :type description: str
    :param display_text: The display text.
    :type display_text: str
    :param relation_guid: The GUID of the relationship.
    :type relation_guid: str
    :param status: The status of term relationship. Possible values include: "DRAFT", "ACTIVE",
     "DEPRECATED", "OBSOLETE", "OTHER".
    :type status: str or ~PurviewCatalog.models.JsonAtlasTermRelationshipStatus
    """

    _attribute_map = {
        'category_guid': {'key': 'categoryGuid', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'display_text': {'key': 'displayText', 'type': 'str'},
        'relation_guid': {'key': 'relationGuid', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        category_guid: Optional[str] = None,
        description: Optional[str] = None,
        display_text: Optional[str] = None,
        relation_guid: Optional[str] = None,
        status: Optional[Union[str, "JsonAtlasTermRelationshipStatus"]] = None,
        **kwargs
    ):
        super(JsonAtlasTermCategorizationHeader, self).__init__(**kwargs)
        self.category_guid = category_guid
        self.description = description
        self.display_text = display_text
        self.relation_guid = relation_guid
        self.status = status


class JsonAtlasTypeDefHeader(msrest.serialization.Model):
    """The basic information of the type definition.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasTypeDefHeader, self).__init__(**kwargs)
        self.category = category
        self.guid = guid
        self.name = name


class JsonAtlasTypesDef(msrest.serialization.Model):
    """The definitions of types.

    :param classification_defs: An array of classification definitions.
    :type classification_defs: list[~PurviewCatalog.models.JsonAtlasClassificationDef]
    :param entity_defs: An array of entity definitions.
    :type entity_defs: list[~PurviewCatalog.models.JsonAtlasEntityDef]
    :param enum_defs: An array of enum definitions.
    :type enum_defs: list[~PurviewCatalog.models.JsonAtlasEnumDef]
    :param relationship_defs: An array of relationship definitions.
    :type relationship_defs: list[~PurviewCatalog.models.JsonAtlasRelationshipDef]
    :param struct_defs: An array of struct definitions.
    :type struct_defs: list[~PurviewCatalog.models.JsonAtlasStructDef]
    """

    _attribute_map = {
        'classification_defs': {'key': 'classificationDefs', 'type': '[JsonAtlasClassificationDef]'},
        'entity_defs': {'key': 'entityDefs', 'type': '[JsonAtlasEntityDef]'},
        'enum_defs': {'key': 'enumDefs', 'type': '[JsonAtlasEnumDef]'},
        'relationship_defs': {'key': 'relationshipDefs', 'type': '[JsonAtlasRelationshipDef]'},
        'struct_defs': {'key': 'structDefs', 'type': '[JsonAtlasStructDef]'},
    }

    def __init__(
        self,
        *,
        classification_defs: Optional[List["JsonAtlasClassificationDef"]] = None,
        entity_defs: Optional[List["JsonAtlasEntityDef"]] = None,
        enum_defs: Optional[List["JsonAtlasEnumDef"]] = None,
        relationship_defs: Optional[List["JsonAtlasRelationshipDef"]] = None,
        struct_defs: Optional[List["JsonAtlasStructDef"]] = None,
        **kwargs
    ):
        super(JsonAtlasTypesDef, self).__init__(**kwargs)
        self.classification_defs = classification_defs
        self.entity_defs = entity_defs
        self.enum_defs = enum_defs
        self.relationship_defs = relationship_defs
        self.struct_defs = struct_defs


class JsonAtlasUserSavedSearch(JsonAtlasBaseModelObject):
    """User saved search.

    :param guid: The GUID of the object.
    :type guid: str
    :param name: The name of the saved search.
    :type name: str
    :param owner_name: The owner name of the saved search.
    :type owner_name: str
    :param search_parameters: The parameters used for search.
    :type search_parameters: ~PurviewCatalog.models.JsonSearchParameters
    :param search_type: The enum of saved search type. Possible values include: "BASIC",
     "ADVANCED".
    :type search_type: str or ~PurviewCatalog.models.JsonSavedSearchType
    :param ui_parameters: The UI parameters.
    :type ui_parameters: str
    """

    _attribute_map = {
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'owner_name': {'key': 'ownerName', 'type': 'str'},
        'search_parameters': {'key': 'searchParameters', 'type': 'JsonSearchParameters'},
        'search_type': {'key': 'searchType', 'type': 'str'},
        'ui_parameters': {'key': 'uiParameters', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        owner_name: Optional[str] = None,
        search_parameters: Optional["JsonSearchParameters"] = None,
        search_type: Optional[Union[str, "JsonSavedSearchType"]] = None,
        ui_parameters: Optional[str] = None,
        **kwargs
    ):
        super(JsonAtlasUserSavedSearch, self).__init__(guid=guid, **kwargs)
        self.name = name
        self.owner_name = owner_name
        self.search_parameters = search_parameters
        self.search_type = search_type
        self.ui_parameters = ui_parameters


class JsonAutocompleteResult(msrest.serialization.Model):
    """The result of the autocomplete request.

    :param value:
    :type value: list[~PurviewCatalog.models.JsonAutocompleteResultValue]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[JsonAutocompleteResultValue]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["JsonAutocompleteResultValue"]] = None,
        **kwargs
    ):
        super(JsonAutocompleteResult, self).__init__(**kwargs)
        self.value = value


class JsonAutocompleteResultValue(msrest.serialization.Model):
    """The value item of the autocomplete suggest.

    :param text: The completed term or phrase.
    :type text: str
    :param query_plus_text: The completed search query text.
    :type query_plus_text: str
    """

    _attribute_map = {
        'text': {'key': 'text', 'type': 'str'},
        'query_plus_text': {'key': 'queryPlusText', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        text: Optional[str] = None,
        query_plus_text: Optional[str] = None,
        **kwargs
    ):
        super(JsonAutocompleteResultValue, self).__init__(**kwargs)
        self.text = text
        self.query_plus_text = query_plus_text


class JsonAzureCatalogUser(msrest.serialization.Model):
    """Azure catalog user.

    :param user_id: User ID of the Azure catalog user.
    :type user_id: str
    """

    _attribute_map = {
        'user_id': {'key': 'userId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        user_id: Optional[str] = None,
        **kwargs
    ):
        super(JsonAzureCatalogUser, self).__init__(**kwargs)
        self.user_id = user_id


class JsonCatalogCreationRequest(msrest.serialization.Model):
    """Request for catalog creation.

    :param catalog_name: Name of the catalog.
    :type catalog_name: str
    :param catalog_id: ID of the catalog.
    :type catalog_id: str
    :param creator_user_id: User ID or the creator.
    :type creator_user_id: str
    :param event_hub_connection_string: The connection string of the Event Hubs.
    :type event_hub_connection_string: str
    """

    _attribute_map = {
        'catalog_name': {'key': 'catalogName', 'type': 'str'},
        'catalog_id': {'key': 'catalogId', 'type': 'str'},
        'creator_user_id': {'key': 'creatorUserId', 'type': 'str'},
        'event_hub_connection_string': {'key': 'eventHubConnectionString', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        catalog_name: Optional[str] = None,
        catalog_id: Optional[str] = None,
        creator_user_id: Optional[str] = None,
        event_hub_connection_string: Optional[str] = None,
        **kwargs
    ):
        super(JsonCatalogCreationRequest, self).__init__(**kwargs)
        self.catalog_name = catalog_name
        self.catalog_id = catalog_id
        self.creator_user_id = creator_user_id
        self.event_hub_connection_string = event_hub_connection_string


class JsonCatalogDeletionRequest(msrest.serialization.Model):
    """Request for catalog deletion.

    :param catalog_name: Name of the catalog.
    :type catalog_name: str
    """

    _attribute_map = {
        'catalog_name': {'key': 'catalogName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        catalog_name: Optional[str] = None,
        **kwargs
    ):
        super(JsonCatalogDeletionRequest, self).__init__(**kwargs)
        self.catalog_name = catalog_name


class JsonClassificationAssociateRequest(msrest.serialization.Model):
    """The request for classification association.

    :param classification: An instance of a classification; it doesn't have an identity, this
     object exists only when associated with an entity.
    :type classification: ~PurviewCatalog.models.JsonAtlasClassification
    :param entity_guids: The GUID of the entity.
    :type entity_guids: list[str]
    """

    _attribute_map = {
        'classification': {'key': 'classification', 'type': 'JsonAtlasClassification'},
        'entity_guids': {'key': 'entityGuids', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        classification: Optional["JsonAtlasClassification"] = None,
        entity_guids: Optional[List[str]] = None,
        **kwargs
    ):
        super(JsonClassificationAssociateRequest, self).__init__(**kwargs)
        self.classification = classification
        self.entity_guids = entity_guids


class JsonContactBasic(msrest.serialization.Model):
    """ContactBasic.

    :param id: Azure Active Directory object Id.
    :type id: str
    :param info: addtional information to describe this contact.
    :type info: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'info': {'key': 'info', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        info: Optional[str] = None,
        **kwargs
    ):
        super(JsonContactBasic, self).__init__(**kwargs)
        self.id = id
        self.info = info


class JsonContactSearchResultValue(msrest.serialization.Model):
    """The contact in the search and suggest result.

    :param id: The GUID of the contact.
    :type id: str
    :param info: The description of the contact.
    :type info: str
    :param contact_type: The type of the contact. It can be Expert or Owner for an entity. It can
     be Expert or Steward for a glossary term.
    :type contact_type: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'info': {'key': 'info', 'type': 'str'},
        'contact_type': {'key': 'contactType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        info: Optional[str] = None,
        contact_type: Optional[str] = None,
        **kwargs
    ):
        super(JsonContactSearchResultValue, self).__init__(**kwargs)
        self.id = id
        self.info = info
        self.contact_type = contact_type


class JsonContext(msrest.serialization.Model):
    """The context.

    :param value: The value of the context.
    :type value: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[str] = None,
        **kwargs
    ):
        super(JsonContext, self).__init__(**kwargs)
        self.value = value


class JsonDataScanPermissionCheckRequest(msrest.serialization.Model):
    """Request for data scan permission check.

    :param catalog_name: Name of the catalog.
    :type catalog_name: str
    :param user_id: User ID of the catalog.
    :type user_id: str
    """

    _attribute_map = {
        'catalog_name': {'key': 'catalogName', 'type': 'str'},
        'user_id': {'key': 'userId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        catalog_name: Optional[str] = None,
        user_id: Optional[str] = None,
        **kwargs
    ):
        super(JsonDataScanPermissionCheckRequest, self).__init__(**kwargs)
        self.catalog_name = catalog_name
        self.user_id = user_id


class JsonDataScanPermissionCheckResponse(msrest.serialization.Model):
    """Response for data scan permission check.

    :param result: The result of the response.
    :type result: str
    """

    _attribute_map = {
        'result': {'key': 'result', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        result: Optional[str] = None,
        **kwargs
    ):
        super(JsonDataScanPermissionCheckResponse, self).__init__(**kwargs)
        self.result = result


class JsonDateFormat(msrest.serialization.Model):
    """The date format.

    :param available_locales: An array of available locales.
    :type available_locales: list[str]
    :param calendar:
    :type calendar: float
    :param date_instance: The date format.
    :type date_instance: ~PurviewCatalog.models.JsonDateFormat
    :param date_time_instance: The date format.
    :type date_time_instance: ~PurviewCatalog.models.JsonDateFormat
    :param instance: The date format.
    :type instance: ~PurviewCatalog.models.JsonDateFormat
    :param lenient: Determines the leniency of the date format.
    :type lenient: bool
    :param number_format: The number format.
    :type number_format: ~PurviewCatalog.models.JsonNumberFormat
    :param time_instance: The date format.
    :type time_instance: ~PurviewCatalog.models.JsonDateFormat
    :param time_zone: The timezone information.
    :type time_zone: ~PurviewCatalog.models.JsonTimeZone
    """

    _attribute_map = {
        'available_locales': {'key': 'availableLocales', 'type': '[str]'},
        'calendar': {'key': 'calendar', 'type': 'float'},
        'date_instance': {'key': 'dateInstance', 'type': 'JsonDateFormat'},
        'date_time_instance': {'key': 'dateTimeInstance', 'type': 'JsonDateFormat'},
        'instance': {'key': 'instance', 'type': 'JsonDateFormat'},
        'lenient': {'key': 'lenient', 'type': 'bool'},
        'number_format': {'key': 'numberFormat', 'type': 'JsonNumberFormat'},
        'time_instance': {'key': 'timeInstance', 'type': 'JsonDateFormat'},
        'time_zone': {'key': 'timeZone', 'type': 'JsonTimeZone'},
    }

    def __init__(
        self,
        *,
        available_locales: Optional[List[str]] = None,
        calendar: Optional[float] = None,
        date_instance: Optional["JsonDateFormat"] = None,
        date_time_instance: Optional["JsonDateFormat"] = None,
        instance: Optional["JsonDateFormat"] = None,
        lenient: Optional[bool] = None,
        number_format: Optional["JsonNumberFormat"] = None,
        time_instance: Optional["JsonDateFormat"] = None,
        time_zone: Optional["JsonTimeZone"] = None,
        **kwargs
    ):
        super(JsonDateFormat, self).__init__(**kwargs)
        self.available_locales = available_locales
        self.calendar = calendar
        self.date_instance = date_instance
        self.date_time_instance = date_time_instance
        self.instance = instance
        self.lenient = lenient
        self.number_format = number_format
        self.time_instance = time_instance
        self.time_zone = time_zone


class JsonEntityAuditEventV2(msrest.serialization.Model):
    """Structure of v2 entity audit event.

    :param action: The enum of entity audit actions. Possible values include: "ENTITY_CREATE",
     "ENTITY_UPDATE", "ENTITY_DELETE", "ENTITY_IMPORT_CREATE", "ENTITY_IMPORT_UPDATE",
     "ENTITY_IMPORT_DELETE", "CLASSIFICATION_ADD", "CLASSIFICATION_DELETE", "CLASSIFICATION_UPDATE",
     "PROPAGATED_CLASSIFICATION_ADD", "PROPAGATED_CLASSIFICATION_DELETE",
     "PROPAGATED_CLASSIFICATION_UPDATE", "TERM_ADD", "TERM_DELETE".
    :type action: str or ~PurviewCatalog.models.JsonEntityAuditActionV2
    :param details: The details of the event.
    :type details: str
    :param entity: An instance of an entity - like hive_table, hive_database.
    :type entity: ~PurviewCatalog.models.JsonAtlasEntity
    :param entity_id: The GUID of the entity.
    :type entity_id: str
    :param event_key: The key of the event.
    :type event_key: str
    :param timestamp: The timestamp of the event.
    :type timestamp: long
    :param type: The enum of entity audit type. Possible values include: "ENTITY_AUDIT_V1",
     "ENTITY_AUDIT_V2".
    :type type: str or ~PurviewCatalog.models.JsonEntityAuditType
    :param user: The user of the event.
    :type user: str
    """

    _attribute_map = {
        'action': {'key': 'action', 'type': 'str'},
        'details': {'key': 'details', 'type': 'str'},
        'entity': {'key': 'entity', 'type': 'JsonAtlasEntity'},
        'entity_id': {'key': 'entityId', 'type': 'str'},
        'event_key': {'key': 'eventKey', 'type': 'str'},
        'timestamp': {'key': 'timestamp', 'type': 'long'},
        'type': {'key': 'type', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        action: Optional[Union[str, "JsonEntityAuditActionV2"]] = None,
        details: Optional[str] = None,
        entity: Optional["JsonAtlasEntity"] = None,
        entity_id: Optional[str] = None,
        event_key: Optional[str] = None,
        timestamp: Optional[int] = None,
        type: Optional[Union[str, "JsonEntityAuditType"]] = None,
        user: Optional[str] = None,
        **kwargs
    ):
        super(JsonEntityAuditEventV2, self).__init__(**kwargs)
        self.action = action
        self.details = details
        self.entity = entity
        self.entity_id = entity_id
        self.event_key = event_key
        self.timestamp = timestamp
        self.type = type
        self.user = user


class JsonEntityCreateRequestV2(msrest.serialization.Model):
    """The class for hook notification for type ENTITY_CREATE_V2.

    :param type: Enum of hook notification type. Different behavior will be invoked by the value.
     Possible values include: "TYPE_CREATE", "TYPE_UPDATE", "ENTITY_CREATE",
     "ENTITY_PARTIAL_UPDATE", "ENTITY_FULL_UPDATE", "ENTITY_DELETE", "ENTITY_CREATE_V2",
     "ENTITY_PARTIAL_UPDATE_V2", "ENTITY_FULL_UPDATE_V2", "ENTITY_DELETE_V2".
    :type type: str or ~PurviewCatalog.models.JsonHookNotificationType
    :param user: The user of the notification. Default to be "UNKNOWN".
    :type user: str
    :param entities: An instance of an entity along with extended info - like hive_table,
     hive_database.
    :type entities: ~PurviewCatalog.models.JsonAtlasEntitiesWithExtInfo
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
        'entities': {'key': 'entities', 'type': 'JsonAtlasEntitiesWithExtInfo'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "JsonHookNotificationType"]] = None,
        user: Optional[str] = "UNKNOWN",
        entities: Optional["JsonAtlasEntitiesWithExtInfo"] = None,
        **kwargs
    ):
        super(JsonEntityCreateRequestV2, self).__init__(**kwargs)
        self.type = type
        self.user = user
        self.entities = entities


class JsonEntityDeleteRequestV2(msrest.serialization.Model):
    """The class for hook notification for type ENTITY_DELETE_V2.

    :param type: Enum of hook notification type. Different behavior will be invoked by the value.
     Possible values include: "TYPE_CREATE", "TYPE_UPDATE", "ENTITY_CREATE",
     "ENTITY_PARTIAL_UPDATE", "ENTITY_FULL_UPDATE", "ENTITY_DELETE", "ENTITY_CREATE_V2",
     "ENTITY_PARTIAL_UPDATE_V2", "ENTITY_FULL_UPDATE_V2", "ENTITY_DELETE_V2".
    :type type: str or ~PurviewCatalog.models.JsonHookNotificationType
    :param user: The user of the notification. Default to be "UNKNOWN".
    :type user: str
    :param entities:
    :type entities: list[~PurviewCatalog.models.JsonAtlasObjectId]
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
        'entities': {'key': 'entities', 'type': '[JsonAtlasObjectId]'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "JsonHookNotificationType"]] = None,
        user: Optional[str] = "UNKNOWN",
        entities: Optional[List["JsonAtlasObjectId"]] = None,
        **kwargs
    ):
        super(JsonEntityDeleteRequestV2, self).__init__(**kwargs)
        self.type = type
        self.user = user
        self.entities = entities


class JsonEntityMutationResponse(msrest.serialization.Model):
    """The mutation response of entity.

    :param guid_assignments: A map of GUID assignments with entities.
    :type guid_assignments: dict[str, str]
    :param mutated_entities: The entity headers of mutated entities.
    :type mutated_entities: dict[str, list[~PurviewCatalog.models.JsonAtlasEntityHeader]]
    :param partial_updated_entities: An array of entity headers that partially updated.
    :type partial_updated_entities: list[~PurviewCatalog.models.JsonAtlasEntityHeader]
    """

    _attribute_map = {
        'guid_assignments': {'key': 'guidAssignments', 'type': '{str}'},
        'mutated_entities': {'key': 'mutatedEntities', 'type': '{[JsonAtlasEntityHeader]}'},
        'partial_updated_entities': {'key': 'partialUpdatedEntities', 'type': '[JsonAtlasEntityHeader]'},
    }

    def __init__(
        self,
        *,
        guid_assignments: Optional[Dict[str, str]] = None,
        mutated_entities: Optional[Dict[str, List["JsonAtlasEntityHeader"]]] = None,
        partial_updated_entities: Optional[List["JsonAtlasEntityHeader"]] = None,
        **kwargs
    ):
        super(JsonEntityMutationResponse, self).__init__(**kwargs)
        self.guid_assignments = guid_assignments
        self.mutated_entities = mutated_entities
        self.partial_updated_entities = partial_updated_entities


class JsonEntityPartialUpdateRequestV2(msrest.serialization.Model):
    """The class for hook notification for type ENTITY_PARTIAL_UPDATE_V2.

    :param type: Enum of hook notification type. Different behavior will be invoked by the value.
     Possible values include: "TYPE_CREATE", "TYPE_UPDATE", "ENTITY_CREATE",
     "ENTITY_PARTIAL_UPDATE", "ENTITY_FULL_UPDATE", "ENTITY_DELETE", "ENTITY_CREATE_V2",
     "ENTITY_PARTIAL_UPDATE_V2", "ENTITY_FULL_UPDATE_V2", "ENTITY_DELETE_V2".
    :type type: str or ~PurviewCatalog.models.JsonHookNotificationType
    :param user: The user of the notification. Default to be "UNKNOWN".
    :type user: str
    :param entity_id: Reference to an object-instance of an Atlas type - like entity.
    :type entity_id: ~PurviewCatalog.models.JsonAtlasObjectId
    :param entity: An instance of an entity along with extended info - like hive_table,
     hive_database.
    :type entity: ~PurviewCatalog.models.JsonAtlasEntitiesWithExtInfo
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
        'entity_id': {'key': 'entityId', 'type': 'JsonAtlasObjectId'},
        'entity': {'key': 'entity', 'type': 'JsonAtlasEntitiesWithExtInfo'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "JsonHookNotificationType"]] = None,
        user: Optional[str] = "UNKNOWN",
        entity_id: Optional["JsonAtlasObjectId"] = None,
        entity: Optional["JsonAtlasEntitiesWithExtInfo"] = None,
        **kwargs
    ):
        super(JsonEntityPartialUpdateRequestV2, self).__init__(**kwargs)
        self.type = type
        self.user = user
        self.entity_id = entity_id
        self.entity = entity


class JsonEntityUpdateRequestV2(msrest.serialization.Model):
    """The class for hook notification for type ENTITY_FULL_UPDATE_V2.

    :param type: Enum of hook notification type. Different behavior will be invoked by the value.
     Possible values include: "TYPE_CREATE", "TYPE_UPDATE", "ENTITY_CREATE",
     "ENTITY_PARTIAL_UPDATE", "ENTITY_FULL_UPDATE", "ENTITY_DELETE", "ENTITY_CREATE_V2",
     "ENTITY_PARTIAL_UPDATE_V2", "ENTITY_FULL_UPDATE_V2", "ENTITY_DELETE_V2".
    :type type: str or ~PurviewCatalog.models.JsonHookNotificationType
    :param user: The user of the notification. Default to be "UNKNOWN".
    :type user: str
    :param entities: An instance of an entity along with extended info - like hive_table,
     hive_database.
    :type entities: ~PurviewCatalog.models.JsonAtlasEntitiesWithExtInfo
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
        'entities': {'key': 'entities', 'type': 'JsonAtlasEntitiesWithExtInfo'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "JsonHookNotificationType"]] = None,
        user: Optional[str] = "UNKNOWN",
        entities: Optional["JsonAtlasEntitiesWithExtInfo"] = None,
        **kwargs
    ):
        super(JsonEntityUpdateRequestV2, self).__init__(**kwargs)
        self.type = type
        self.user = user
        self.entities = entities


class JsonError(msrest.serialization.Model):
    """The error response.

    :param error_message: The error message.
    :type error_message: str
    """

    _attribute_map = {
        'error_message': {'key': 'errorMessage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        error_message: Optional[str] = None,
        **kwargs
    ):
        super(JsonError, self).__init__(**kwargs)
        self.error_message = error_message


class JsonFilterCriteria(msrest.serialization.Model):
    """The filter criteria with attributes and condition.

    :param attribute_name: The name of the attribute.
    :type attribute_name: str
    :param attribute_value: The value of the attribute.
    :type attribute_value: str
    :param condition: The enum for condition. Possible values include: "AND", "OR".
    :type condition: str or ~PurviewCatalog.models.JsonCondition
    :param criterion: An array of filter criteria.
    :type criterion: list[~PurviewCatalog.models.JsonFilterCriteria]
    :param operator: Supported search operations
     Logical comparision operators can only be used with numbers or dates
     IN, LIKE, startsWith, endsWith, CONTAINS can only be used with strings or text. Possible
     values include: "LT", "GT", "LTE", "GTE", "EQ", "NEQ", "IN", "LIKE", "STARTS_WITH",
     "ENDS_WITH", "CONTAINS", "CONTAINS_ANY", "CONTAINS_ALL", "IS_NULL", "NOT_NULL".
    :type operator: str or ~PurviewCatalog.models.JsonOperator
    """

    _attribute_map = {
        'attribute_name': {'key': 'attributeName', 'type': 'str'},
        'attribute_value': {'key': 'attributeValue', 'type': 'str'},
        'condition': {'key': 'condition', 'type': 'str'},
        'criterion': {'key': 'criterion', 'type': '[JsonFilterCriteria]'},
        'operator': {'key': 'operator', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        attribute_name: Optional[str] = None,
        attribute_value: Optional[str] = None,
        condition: Optional[Union[str, "JsonCondition"]] = None,
        criterion: Optional[List["JsonFilterCriteria"]] = None,
        operator: Optional[Union[str, "JsonOperator"]] = None,
        **kwargs
    ):
        super(JsonFilterCriteria, self).__init__(**kwargs)
        self.attribute_name = attribute_name
        self.attribute_value = attribute_value
        self.condition = condition
        self.criterion = criterion
        self.operator = operator


class JsonHookNotification(msrest.serialization.Model):
    """The base class for hook notification.

    :param type: Enum of hook notification type. Different behavior will be invoked by the value.
     Possible values include: "TYPE_CREATE", "TYPE_UPDATE", "ENTITY_CREATE",
     "ENTITY_PARTIAL_UPDATE", "ENTITY_FULL_UPDATE", "ENTITY_DELETE", "ENTITY_CREATE_V2",
     "ENTITY_PARTIAL_UPDATE_V2", "ENTITY_FULL_UPDATE_V2", "ENTITY_DELETE_V2".
    :type type: str or ~PurviewCatalog.models.JsonHookNotificationType
    :param user: The user of the notification. Default to be "UNKNOWN".
    :type user: str
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "JsonHookNotificationType"]] = None,
        user: Optional[str] = "UNKNOWN",
        **kwargs
    ):
        super(JsonHookNotification, self).__init__(**kwargs)
        self.type = type
        self.user = user


class JsonImportCSVOperation(msrest.serialization.Model):
    """The status of import csv operation.

    :param id: guid string.
    :type id: str
    :param status: Enum of the status of import csv operation. Possible values include: "INIT",
     "SUCCEED", "FAILED", "RUNNING".
    :type status: str or ~PurviewCatalog.models.JsonImportCSVOperationStatus
    :param create_time: The created time of the record.
    :type create_time: float
    :param last_update_time: The last updated time of the record.
    :type last_update_time: float
    :param properties:
    :type properties: ~PurviewCatalog.models.JsonImportCSVOperationProperties
    :param error:
    :type error: ~PurviewCatalog.models.JsonImportCSVOperationError
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'last_update_time': {'key': 'lastUpdateTime', 'type': 'float'},
        'properties': {'key': 'properties', 'type': 'JsonImportCSVOperationProperties'},
        'error': {'key': 'error', 'type': 'JsonImportCSVOperationError'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        status: Optional[Union[str, "JsonImportCSVOperationStatus"]] = None,
        create_time: Optional[float] = None,
        last_update_time: Optional[float] = None,
        properties: Optional["JsonImportCSVOperationProperties"] = None,
        error: Optional["JsonImportCSVOperationError"] = None,
        **kwargs
    ):
        super(JsonImportCSVOperation, self).__init__(**kwargs)
        self.id = id
        self.status = status
        self.create_time = create_time
        self.last_update_time = last_update_time
        self.properties = properties
        self.error = error


class JsonImportCSVOperationError(msrest.serialization.Model):
    """JsonImportCSVOperationError.

    :param error_code: Error code from async import job if fail.
    :type error_code: float
    :param error_message: Error message from async import job if fail.
    :type error_message: str
    """

    _attribute_map = {
        'error_code': {'key': 'errorCode', 'type': 'float'},
        'error_message': {'key': 'errorMessage', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        error_code: Optional[float] = None,
        error_message: Optional[str] = None,
        **kwargs
    ):
        super(JsonImportCSVOperationError, self).__init__(**kwargs)
        self.error_code = error_code
        self.error_message = error_message


class JsonImportCSVOperationProperties(msrest.serialization.Model):
    """JsonImportCSVOperationProperties.

    :param imported_terms: Term numbers that already imported successfully.
    :type imported_terms: float
    :param total_terms_detect: Total term numbers that detected in csv.
    :type total_terms_detect: float
    """

    _attribute_map = {
        'imported_terms': {'key': 'importedTerms', 'type': 'float'},
        'total_terms_detect': {'key': 'totalTermsDetect', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        imported_terms: Optional[float] = None,
        total_terms_detect: Optional[float] = None,
        **kwargs
    ):
        super(JsonImportCSVOperationProperties, self).__init__(**kwargs)
        self.imported_terms = imported_terms
        self.total_terms_detect = total_terms_detect


class JsonLineageRelation(msrest.serialization.Model):
    """The lineage relation with GUID of the from and to entity.

    :param from_entity_id: The GUID of from-entity.
    :type from_entity_id: str
    :param relationship_id: The GUID of relationship.
    :type relationship_id: str
    :param to_entity_id: The GUID of to-entity.
    :type to_entity_id: str
    """

    _attribute_map = {
        'from_entity_id': {'key': 'fromEntityId', 'type': 'str'},
        'relationship_id': {'key': 'relationshipId', 'type': 'str'},
        'to_entity_id': {'key': 'toEntityId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        from_entity_id: Optional[str] = None,
        relationship_id: Optional[str] = None,
        to_entity_id: Optional[str] = None,
        **kwargs
    ):
        super(JsonLineageRelation, self).__init__(**kwargs)
        self.from_entity_id = from_entity_id
        self.relationship_id = relationship_id
        self.to_entity_id = to_entity_id


class JsonListRoleAssignmentResponse(msrest.serialization.Model):
    """The response of listing role assignments.

    :param role_assignment_list:
    :type role_assignment_list: list[~PurviewCatalog.models.JsonRoleAssignmentEntry]
    """

    _attribute_map = {
        'role_assignment_list': {'key': 'roleAssignmentList', 'type': '[JsonRoleAssignmentEntry]'},
    }

    def __init__(
        self,
        *,
        role_assignment_list: Optional[List["JsonRoleAssignmentEntry"]] = None,
        **kwargs
    ):
        super(JsonListRoleAssignmentResponse, self).__init__(**kwargs)
        self.role_assignment_list = role_assignment_list


class JsonNumberFormat(msrest.serialization.Model):
    """The number format.

    :param available_locales: The number format.
    :type available_locales: list[str]
    :param currency: The currency.
    :type currency: str
    :param currency_instance: The number format.
    :type currency_instance: ~PurviewCatalog.models.JsonNumberFormat
    :param grouping_used: Determines if grouping is used.
    :type grouping_used: bool
    :param instance: The number format.
    :type instance: ~PurviewCatalog.models.JsonNumberFormat
    :param integer_instance: The number format.
    :type integer_instance: ~PurviewCatalog.models.JsonNumberFormat
    :param maximum_fraction_digits: The maximum of fraction digits.
    :type maximum_fraction_digits: int
    :param maximum_integer_digits: The maximum of integer digits.
    :type maximum_integer_digits: int
    :param minimum_fraction_digits: The minimum of fraction digits.
    :type minimum_fraction_digits: int
    :param minimum_integer_digits: The minimum of integer digits.
    :type minimum_integer_digits: int
    :param number_instance: The number format.
    :type number_instance: ~PurviewCatalog.models.JsonNumberFormat
    :param parse_integer_only: Determines if only integer is parsed.
    :type parse_integer_only: bool
    :param percent_instance: The number format.
    :type percent_instance: ~PurviewCatalog.models.JsonNumberFormat
    :param rounding_mode: The enum of rounding mode. Possible values include: "UP", "DOWN",
     "CEILING", "FLOOR", "HALF_UP", "HALF_DOWN", "HALF_EVEN", "UNNECESSARY".
    :type rounding_mode: str or ~PurviewCatalog.models.JsonRoundingMode
    """

    _attribute_map = {
        'available_locales': {'key': 'availableLocales', 'type': '[str]'},
        'currency': {'key': 'currency', 'type': 'str'},
        'currency_instance': {'key': 'currencyInstance', 'type': 'JsonNumberFormat'},
        'grouping_used': {'key': 'groupingUsed', 'type': 'bool'},
        'instance': {'key': 'instance', 'type': 'JsonNumberFormat'},
        'integer_instance': {'key': 'integerInstance', 'type': 'JsonNumberFormat'},
        'maximum_fraction_digits': {'key': 'maximumFractionDigits', 'type': 'int'},
        'maximum_integer_digits': {'key': 'maximumIntegerDigits', 'type': 'int'},
        'minimum_fraction_digits': {'key': 'minimumFractionDigits', 'type': 'int'},
        'minimum_integer_digits': {'key': 'minimumIntegerDigits', 'type': 'int'},
        'number_instance': {'key': 'numberInstance', 'type': 'JsonNumberFormat'},
        'parse_integer_only': {'key': 'parseIntegerOnly', 'type': 'bool'},
        'percent_instance': {'key': 'percentInstance', 'type': 'JsonNumberFormat'},
        'rounding_mode': {'key': 'roundingMode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        available_locales: Optional[List[str]] = None,
        currency: Optional[str] = None,
        currency_instance: Optional["JsonNumberFormat"] = None,
        grouping_used: Optional[bool] = None,
        instance: Optional["JsonNumberFormat"] = None,
        integer_instance: Optional["JsonNumberFormat"] = None,
        maximum_fraction_digits: Optional[int] = None,
        maximum_integer_digits: Optional[int] = None,
        minimum_fraction_digits: Optional[int] = None,
        minimum_integer_digits: Optional[int] = None,
        number_instance: Optional["JsonNumberFormat"] = None,
        parse_integer_only: Optional[bool] = None,
        percent_instance: Optional["JsonNumberFormat"] = None,
        rounding_mode: Optional[Union[str, "JsonRoundingMode"]] = None,
        **kwargs
    ):
        super(JsonNumberFormat, self).__init__(**kwargs)
        self.available_locales = available_locales
        self.currency = currency
        self.currency_instance = currency_instance
        self.grouping_used = grouping_used
        self.instance = instance
        self.integer_instance = integer_instance
        self.maximum_fraction_digits = maximum_fraction_digits
        self.maximum_integer_digits = maximum_integer_digits
        self.minimum_fraction_digits = minimum_fraction_digits
        self.minimum_integer_digits = minimum_integer_digits
        self.number_instance = number_instance
        self.parse_integer_only = parse_integer_only
        self.percent_instance = percent_instance
        self.rounding_mode = rounding_mode


class JsonParentRelation(msrest.serialization.Model):
    """The lineage parents relation with GUID of the parent entity and to child entity.

    :param child_entity_id: The GUID of child entity.
    :type child_entity_id: str
    :param relationship_id: The GUID of relationship.
    :type relationship_id: str
    :param parent_entity_id: The GUID of parent entity.
    :type parent_entity_id: str
    """

    _attribute_map = {
        'child_entity_id': {'key': 'childEntityId', 'type': 'str'},
        'relationship_id': {'key': 'relationshipId', 'type': 'str'},
        'parent_entity_id': {'key': 'parentEntityId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        child_entity_id: Optional[str] = None,
        relationship_id: Optional[str] = None,
        parent_entity_id: Optional[str] = None,
        **kwargs
    ):
        super(JsonParentRelation, self).__init__(**kwargs)
        self.child_entity_id = child_entity_id
        self.relationship_id = relationship_id
        self.parent_entity_id = parent_entity_id


class JsonResourceLink(msrest.serialization.Model):
    """ResourceLink.

    :param display_name: Display name for url.
    :type display_name: str
    :param url: web url. http or https.
    :type url: str
    """

    _attribute_map = {
        'display_name': {'key': 'displayName', 'type': 'str'},
        'url': {'key': 'url', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        display_name: Optional[str] = None,
        url: Optional[str] = None,
        **kwargs
    ):
        super(JsonResourceLink, self).__init__(**kwargs)
        self.display_name = display_name
        self.url = url


class JsonRoleAssignmentEntry(msrest.serialization.Model):
    """A role assignment.

    :param principal_id: The object ID of the AAD user.
    :type principal_id: str
    :param role: The name of the role.
    :type role: str
    """

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'role': {'key': 'role', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        principal_id: Optional[str] = None,
        role: Optional[str] = None,
        **kwargs
    ):
        super(JsonRoleAssignmentEntry, self).__init__(**kwargs)
        self.principal_id = principal_id
        self.role = role


class JsonSearchFacetItemValue(msrest.serialization.Model):
    """The content of a search facet result item.

    :param count: The count of the facet item.
    :type count: int
    :param value: The name of the facet item.
    :type value: str
    """

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(JsonSearchFacetItemValue, self).__init__(**kwargs)
        self.count = count
        self.value = value


class JsonSearchFacetResultValue(msrest.serialization.Model):
    """A facet list that consists of index fields assetType ,classification, classificationCategory, contactId, fileExtension, label, and label. When the facet is specified in the request, the value of the facet is returned as an element of @search.facets.

    :param asset_type:
    :type asset_type: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    :param classification:
    :type classification: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    :param classification_category:
    :type classification_category: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    :param contact_id:
    :type contact_id: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    :param file_extension:
    :type file_extension: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    :param label:
    :type label: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    :param term:
    :type term: list[~PurviewCatalog.models.JsonSearchFacetItemValue]
    """

    _attribute_map = {
        'asset_type': {'key': 'assetType', 'type': '[JsonSearchFacetItemValue]'},
        'classification': {'key': 'classification', 'type': '[JsonSearchFacetItemValue]'},
        'classification_category': {'key': 'classificationCategory', 'type': '[JsonSearchFacetItemValue]'},
        'contact_id': {'key': 'contactId', 'type': '[JsonSearchFacetItemValue]'},
        'file_extension': {'key': 'fileExtension', 'type': '[JsonSearchFacetItemValue]'},
        'label': {'key': 'label', 'type': '[JsonSearchFacetItemValue]'},
        'term': {'key': 'term', 'type': '[JsonSearchFacetItemValue]'},
    }

    def __init__(
        self,
        *,
        asset_type: Optional[List["JsonSearchFacetItemValue"]] = None,
        classification: Optional[List["JsonSearchFacetItemValue"]] = None,
        classification_category: Optional[List["JsonSearchFacetItemValue"]] = None,
        contact_id: Optional[List["JsonSearchFacetItemValue"]] = None,
        file_extension: Optional[List["JsonSearchFacetItemValue"]] = None,
        label: Optional[List["JsonSearchFacetItemValue"]] = None,
        term: Optional[List["JsonSearchFacetItemValue"]] = None,
        **kwargs
    ):
        super(JsonSearchFacetResultValue, self).__init__(**kwargs)
        self.asset_type = asset_type
        self.classification = classification
        self.classification_category = classification_category
        self.contact_id = contact_id
        self.file_extension = file_extension
        self.label = label
        self.term = term


class JsonSearchFilter(msrest.serialization.Model):
    """Generic filter, to specify search criteria using name/value pairs.

    :param get_count: Determines if get the count.
    :type get_count: bool
    :param max_rows: The maximum of rows.
    :type max_rows: long
    :param params: The parameters of the search filter.
    :type params: dict[str, list[str]]
    :param sort_by: The sorted by field.
    :type sort_by: str
    :param sort_type: to specify whether the result should be sorted? If yes, whether asc or desc.
     Possible values include: "NONE", "ASC", "DESC".
    :type sort_type: str or ~PurviewCatalog.models.JsonSortType
    :param start_index: The start index of the search.
    :type start_index: long
    """

    _attribute_map = {
        'get_count': {'key': 'getCount', 'type': 'bool'},
        'max_rows': {'key': 'maxRows', 'type': 'long'},
        'params': {'key': 'params', 'type': '{[str]}'},
        'sort_by': {'key': 'sortBy', 'type': 'str'},
        'sort_type': {'key': 'sortType', 'type': 'str'},
        'start_index': {'key': 'startIndex', 'type': 'long'},
    }

    def __init__(
        self,
        *,
        get_count: Optional[bool] = None,
        max_rows: Optional[int] = None,
        params: Optional[Dict[str, List[str]]] = None,
        sort_by: Optional[str] = None,
        sort_type: Optional[Union[str, "JsonSortType"]] = None,
        start_index: Optional[int] = None,
        **kwargs
    ):
        super(JsonSearchFilter, self).__init__(**kwargs)
        self.get_count = get_count
        self.max_rows = max_rows
        self.params = params
        self.sort_by = sort_by
        self.sort_type = sort_type
        self.start_index = start_index


class JsonSearchHighlights(msrest.serialization.Model):
    """A highlight list that consists of index fields id ,qualifiedName, name, description, entityType. When the keyword appears in those fields, the value of the field, attached with emphasis mark, is returned as an element of @search.highlights.

    :param id:
    :type id: list[str]
    :param qualified_name:
    :type qualified_name: list[str]
    :param name:
    :type name: list[str]
    :param description:
    :type description: list[str]
    :param entity_type:
    :type entity_type: list[str]
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': '[str]'},
        'qualified_name': {'key': 'qualifiedName', 'type': '[str]'},
        'name': {'key': 'name', 'type': '[str]'},
        'description': {'key': 'description', 'type': '[str]'},
        'entity_type': {'key': 'entityType', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        id: Optional[List[str]] = None,
        qualified_name: Optional[List[str]] = None,
        name: Optional[List[str]] = None,
        description: Optional[List[str]] = None,
        entity_type: Optional[List[str]] = None,
        **kwargs
    ):
        super(JsonSearchHighlights, self).__init__(**kwargs)
        self.id = id
        self.qualified_name = qualified_name
        self.name = name
        self.description = description
        self.entity_type = entity_type


class JsonSearchParameters(msrest.serialization.Model):
    """The parameters used for search.

    :param attributes: Attribute values included in the results.
    :type attributes: list[str]
    :param classification: The classification to search.
    :type classification: str
    :param entity_filters: The filter criteria with attributes and condition.
    :type entity_filters: ~PurviewCatalog.models.JsonFilterCriteria
    :param exclude_deleted_entities: Determines if exclude deleted entities.
    :type exclude_deleted_entities: bool
    :param include_classification_attributes: Determines if include classification attributes.
    :type include_classification_attributes: bool
    :param include_sub_classifications: Determines if include sub classifications.
    :type include_sub_classifications: bool
    :param include_sub_types: Determines if include sub types.
    :type include_sub_types: bool
    :param limit: The limit of the search result.
    :type limit: int
    :param offset: The offset of the search.
    :type offset: int
    :param query: The search query.
    :type query: str
    :param tag_filters: The filter criteria with attributes and condition.
    :type tag_filters: ~PurviewCatalog.models.JsonFilterCriteria
    :param term_name: The name of the term for search.
    :type term_name: str
    :param type_name: The name of the type for search.
    :type type_name: str
    """

    _attribute_map = {
        'attributes': {'key': 'attributes', 'type': '[str]'},
        'classification': {'key': 'classification', 'type': 'str'},
        'entity_filters': {'key': 'entityFilters', 'type': 'JsonFilterCriteria'},
        'exclude_deleted_entities': {'key': 'excludeDeletedEntities', 'type': 'bool'},
        'include_classification_attributes': {'key': 'includeClassificationAttributes', 'type': 'bool'},
        'include_sub_classifications': {'key': 'includeSubClassifications', 'type': 'bool'},
        'include_sub_types': {'key': 'includeSubTypes', 'type': 'bool'},
        'limit': {'key': 'limit', 'type': 'int'},
        'offset': {'key': 'offset', 'type': 'int'},
        'query': {'key': 'query', 'type': 'str'},
        'tag_filters': {'key': 'tagFilters', 'type': 'JsonFilterCriteria'},
        'term_name': {'key': 'termName', 'type': 'str'},
        'type_name': {'key': 'typeName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        attributes: Optional[List[str]] = None,
        classification: Optional[str] = None,
        entity_filters: Optional["JsonFilterCriteria"] = None,
        exclude_deleted_entities: Optional[bool] = None,
        include_classification_attributes: Optional[bool] = None,
        include_sub_classifications: Optional[bool] = None,
        include_sub_types: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        query: Optional[str] = None,
        tag_filters: Optional["JsonFilterCriteria"] = None,
        term_name: Optional[str] = None,
        type_name: Optional[str] = None,
        **kwargs
    ):
        super(JsonSearchParameters, self).__init__(**kwargs)
        self.attributes = attributes
        self.classification = classification
        self.entity_filters = entity_filters
        self.exclude_deleted_entities = exclude_deleted_entities
        self.include_classification_attributes = include_classification_attributes
        self.include_sub_classifications = include_sub_classifications
        self.include_sub_types = include_sub_types
        self.limit = limit
        self.offset = offset
        self.query = query
        self.tag_filters = tag_filters
        self.term_name = term_name
        self.type_name = type_name


class JsonSearchRequest(msrest.serialization.Model):
    """The search query of advanced search request.

    :param keywords: The keywords applied to all searchable fields.
    :type keywords: str
    :param offset: The offset. The default value is 0.
    :type offset: int
    :param limit: The limit of the number of the search result. default value is 50; maximum value
     is 1000.
    :type limit: int
    :param filter: The filter for the search. See examples for the usage of supported filters.
    :type filter: object
    """

    _attribute_map = {
        'keywords': {'key': 'keywords', 'type': 'str'},
        'offset': {'key': 'offset', 'type': 'int'},
        'limit': {'key': 'limit', 'type': 'int'},
        'filter': {'key': 'filter', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        keywords: Optional[str] = None,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        filter: Optional[object] = None,
        **kwargs
    ):
        super(JsonSearchRequest, self).__init__(**kwargs)
        self.keywords = keywords
        self.offset = offset
        self.limit = limit
        self.filter = filter


class JsonSearchResultValue(msrest.serialization.Model):
    """The value item of the search result.

    :param search_score: The search score calculated by the search engine. The results are ordered
     by search score by default.
    :type search_score: float
    :param search_highlights: A highlight list that consists of index fields id ,qualifiedName,
     name, description, entityType. When the keyword appears in those fields, the value of the
     field, attached with emphasis mark, is returned as an element of @search.highlights.
    :type search_highlights: ~PurviewCatalog.models.JsonSearchHighlights
    :param search_text: The target text that contains the keyword as prefix. The keyword is wrapped
     with emphasis mark.
    :type search_text: str
    :param description: The description of the record.
    :type description: str
    :param id: The GUID of the record.
    :type id: str
    :param name: The name of the record.
    :type name: str
    :param owner: The owner of the record. This is an Atlas native attribute.
    :type owner: str
    :param qualified_name: The qualified name of the record.
    :type qualified_name: str
    :param entity_type: The type name of the record.
    :type entity_type: str
    :param classification: The classifications of the record.
    :type classification: list[str]
    :param label: The labels of the record.
    :type label: list[str]
    :param term: The terms assigned to the record.
    :type term: list[~PurviewCatalog.models.JsonTermSearchResultValue]
    :param contact: The contacts of the record.
    :type contact: list[~PurviewCatalog.models.JsonContactSearchResultValue]
    :param asset_type: The asset types of the record.
    :type asset_type: list[str]
    """

    _attribute_map = {
        'search_score': {'key': '@search\\.score', 'type': 'float'},
        'search_highlights': {'key': '@search\\.highlights', 'type': 'JsonSearchHighlights'},
        'search_text': {'key': '@search\\.text', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'owner': {'key': 'owner', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'classification': {'key': 'classification', 'type': '[str]'},
        'label': {'key': 'label', 'type': '[str]'},
        'term': {'key': 'term', 'type': '[JsonTermSearchResultValue]'},
        'contact': {'key': 'contact', 'type': '[JsonContactSearchResultValue]'},
        'asset_type': {'key': 'assetType', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        search_score: Optional[float] = None,
        search_highlights: Optional["JsonSearchHighlights"] = None,
        search_text: Optional[str] = None,
        description: Optional[str] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        qualified_name: Optional[str] = None,
        entity_type: Optional[str] = None,
        classification: Optional[List[str]] = None,
        label: Optional[List[str]] = None,
        term: Optional[List["JsonTermSearchResultValue"]] = None,
        contact: Optional[List["JsonContactSearchResultValue"]] = None,
        asset_type: Optional[List[str]] = None,
        **kwargs
    ):
        super(JsonSearchResultValue, self).__init__(**kwargs)
        self.search_score = search_score
        self.search_highlights = search_highlights
        self.search_text = search_text
        self.description = description
        self.id = id
        self.name = name
        self.owner = owner
        self.qualified_name = qualified_name
        self.entity_type = entity_type
        self.classification = classification
        self.label = label
        self.term = term
        self.contact = contact
        self.asset_type = asset_type


class JsonSuggestRequest(msrest.serialization.Model):
    """The query of suggest request.

    :param keywords: The keywords applied to all fields that support suggest operation. It must be
     at least 1 character, and no more than 100 characters. In the index schema we defined a default
     suggester which lists all the supported fields and specifies a search mode.
    :type keywords: str
    :param limit: The number of suggestions we hope to return. The default value is 5. The value
     must be a number between 1 and 100.
    :type limit: int
    :param filter: The filter for the search.
    :type filter: object
    """

    _attribute_map = {
        'keywords': {'key': 'keywords', 'type': 'str'},
        'limit': {'key': 'limit', 'type': 'int'},
        'filter': {'key': 'filter', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        keywords: Optional[str] = None,
        limit: Optional[int] = None,
        filter: Optional[object] = None,
        **kwargs
    ):
        super(JsonSuggestRequest, self).__init__(**kwargs)
        self.keywords = keywords
        self.limit = limit
        self.filter = filter


class JsonSuggestResult(msrest.serialization.Model):
    """The result item of the search suggest.

    :param value:
    :type value: list[~PurviewCatalog.models.JsonSuggestResultValue]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[JsonSuggestResultValue]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["JsonSuggestResultValue"]] = None,
        **kwargs
    ):
        super(JsonSuggestResult, self).__init__(**kwargs)
        self.value = value


class JsonSuggestResultValue(msrest.serialization.Model):
    """The value item of the search suggest.

    :param search_score: The search score calculated by the search engine. The results are ordered
     by search score by default.
    :type search_score: float
    :param search_text: The target text that contains the keyword as prefix. The keyword is wrapped
     with emphasis mark.
    :type search_text: str
    :param description: The description of the record.
    :type description: str
    :param id: The GUID of the record.
    :type id: str
    :param name: The name of the record.
    :type name: str
    :param owner: The owner of the record. This is an Atlas native attribute.
    :type owner: str
    :param qualified_name: The qualified name of the record.
    :type qualified_name: str
    :param entity_type: The type name of the record.
    :type entity_type: str
    :param classification: The classifications of the record.
    :type classification: list[str]
    :param label: The labels of the record.
    :type label: list[str]
    :param term: The terms assigned to the record.
    :type term: list[~PurviewCatalog.models.JsonTermSearchResultValue]
    :param contact: The contacts of the record.
    :type contact: list[~PurviewCatalog.models.JsonContactSearchResultValue]
    :param asset_type: The asset types of the record.
    :type asset_type: list[str]
    """

    _attribute_map = {
        'search_score': {'key': '@search\\.score', 'type': 'float'},
        'search_text': {'key': '@search\\.text', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'owner': {'key': 'owner', 'type': 'str'},
        'qualified_name': {'key': 'qualifiedName', 'type': 'str'},
        'entity_type': {'key': 'entityType', 'type': 'str'},
        'classification': {'key': 'classification', 'type': '[str]'},
        'label': {'key': 'label', 'type': '[str]'},
        'term': {'key': 'term', 'type': '[JsonTermSearchResultValue]'},
        'contact': {'key': 'contact', 'type': '[JsonContactSearchResultValue]'},
        'asset_type': {'key': 'assetType', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        search_score: Optional[float] = None,
        search_text: Optional[str] = None,
        description: Optional[str] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        qualified_name: Optional[str] = None,
        entity_type: Optional[str] = None,
        classification: Optional[List[str]] = None,
        label: Optional[List[str]] = None,
        term: Optional[List["JsonTermSearchResultValue"]] = None,
        contact: Optional[List["JsonContactSearchResultValue"]] = None,
        asset_type: Optional[List[str]] = None,
        **kwargs
    ):
        super(JsonSuggestResultValue, self).__init__(**kwargs)
        self.search_score = search_score
        self.search_text = search_text
        self.description = description
        self.id = id
        self.name = name
        self.owner = owner
        self.qualified_name = qualified_name
        self.entity_type = entity_type
        self.classification = classification
        self.label = label
        self.term = term
        self.contact = contact
        self.asset_type = asset_type


class JsonTermSearchResultValue(msrest.serialization.Model):
    """The context.

    :param name: The name of the term.
    :type name: str
    :param glossary_name: The name of the glossary which contains the term.
    :type glossary_name: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'glossary_name': {'key': 'glossaryName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        glossary_name: Optional[str] = None,
        **kwargs
    ):
        super(JsonTermSearchResultValue, self).__init__(**kwargs)
        self.name = name
        self.glossary_name = glossary_name


class JsonTermTemplateDef(JsonAtlasStructDef):
    """term template definition for glossary term.

    :param category: The enum of type category. Possible values include: "PRIMITIVE",
     "OBJECT_ID_TYPE", "ENUM", "STRUCT", "CLASSIFICATION", "ENTITY", "ARRAY", "MAP", "RELATIONSHIP",
     "TERM_TEMPLATE".
    :type category: str or ~PurviewCatalog.models.JsonTypeCategory
    :param create_time: The created time of the record.
    :type create_time: float
    :param created_by: The user who created the record.
    :type created_by: str
    :param date_formatter: The date format.
    :type date_formatter: ~PurviewCatalog.models.JsonDateFormat
    :param description: The description of the type definition.
    :type description: str
    :param guid: The GUID of the type definition.
    :type guid: str
    :param name: The name of the type definition.
    :type name: str
    :param options: The options for the type definition.
    :type options: dict[str, str]
    :param service_type: The service type.
    :type service_type: str
    :param type_version: The version of the type.
    :type type_version: str
    :param update_time: The update time of the record.
    :type update_time: float
    :param updated_by: The user who updated the record.
    :type updated_by: str
    :param version: The version of the record.
    :type version: float
    :param last_modified_ts: ETag for concurrency control.
    :type last_modified_ts: str
    :param attribute_defs: An array of attribute definitions.
    :type attribute_defs: list[~PurviewCatalog.models.JsonAtlasAttributeDef]
    """

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'float'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'date_formatter': {'key': 'dateFormatter', 'type': 'JsonDateFormat'},
        'description': {'key': 'description', 'type': 'str'},
        'guid': {'key': 'guid', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'options': {'key': 'options', 'type': '{str}'},
        'service_type': {'key': 'serviceType', 'type': 'str'},
        'type_version': {'key': 'typeVersion', 'type': 'str'},
        'update_time': {'key': 'updateTime', 'type': 'float'},
        'updated_by': {'key': 'updatedBy', 'type': 'str'},
        'version': {'key': 'version', 'type': 'float'},
        'last_modified_ts': {'key': 'lastModifiedTS', 'type': 'str'},
        'attribute_defs': {'key': 'attributeDefs', 'type': '[JsonAtlasAttributeDef]'},
    }

    def __init__(
        self,
        *,
        category: Optional[Union[str, "JsonTypeCategory"]] = None,
        create_time: Optional[float] = None,
        created_by: Optional[str] = None,
        date_formatter: Optional["JsonDateFormat"] = None,
        description: Optional[str] = None,
        guid: Optional[str] = None,
        name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        service_type: Optional[str] = None,
        type_version: Optional[str] = None,
        update_time: Optional[float] = None,
        updated_by: Optional[str] = None,
        version: Optional[float] = None,
        last_modified_ts: Optional[str] = None,
        attribute_defs: Optional[List["JsonAtlasAttributeDef"]] = None,
        **kwargs
    ):
        super(JsonTermTemplateDef, self).__init__(category=category, create_time=create_time, created_by=created_by, date_formatter=date_formatter, description=description, guid=guid, name=name, options=options, service_type=service_type, type_version=type_version, update_time=update_time, updated_by=updated_by, version=version, last_modified_ts=last_modified_ts, attribute_defs=attribute_defs, **kwargs)


class JsonTimeBoundary(msrest.serialization.Model):
    """Captures time-boundary details.

    :param end_time: The end of the time boundary.
    :type end_time: str
    :param start_time: The start of the time boundary.
    :type start_time: str
    :param time_zone: The timezone of the time boundary.
    :type time_zone: str
    """

    _attribute_map = {
        'end_time': {'key': 'endTime', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'str'},
        'time_zone': {'key': 'timeZone', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        end_time: Optional[str] = None,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
        **kwargs
    ):
        super(JsonTimeBoundary, self).__init__(**kwargs)
        self.end_time = end_time
        self.start_time = start_time
        self.time_zone = time_zone


class JsonTimeZone(msrest.serialization.Model):
    """The timezone information.

    :param dst_savings: The value of the daylight saving time.
    :type dst_savings: int
    :param id: The ID of the timezone.
    :type id: str
    :param available_i_ds: An array of available IDs.
    :type available_i_ds: list[str]
    :param default: The timezone information.
    :type default: ~PurviewCatalog.models.JsonTimeZone
    :param display_name: The display name of the timezone.
    :type display_name: str
    :param raw_offset: The raw offset of the timezone.
    :type raw_offset: int
    """

    _attribute_map = {
        'dst_savings': {'key': 'DSTSavings', 'type': 'int'},
        'id': {'key': 'ID', 'type': 'str'},
        'available_i_ds': {'key': 'availableIDs', 'type': '[str]'},
        'default': {'key': 'default', 'type': 'JsonTimeZone'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'raw_offset': {'key': 'rawOffset', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        dst_savings: Optional[int] = None,
        id: Optional[str] = None,
        available_i_ds: Optional[List[str]] = None,
        default: Optional["JsonTimeZone"] = None,
        display_name: Optional[str] = None,
        raw_offset: Optional[int] = None,
        **kwargs
    ):
        super(JsonTimeZone, self).__init__(**kwargs)
        self.dst_savings = dst_savings
        self.id = id
        self.available_i_ds = available_i_ds
        self.default = default
        self.display_name = display_name
        self.raw_offset = raw_offset


class JsonTypeStatistics(msrest.serialization.Model):
    """The types and corresponding statistics.

    :param type_statistics: An map with type and corresponding statistics.
    :type type_statistics: dict[str,
     ~PurviewCatalog.models.ComponentsV9D1InSchemasJsonTypestatisticsPropertiesTypestatisticsAdditionalproperties]
    """

    _attribute_map = {
        'type_statistics': {'key': 'typeStatistics', 'type': '{ComponentsV9D1InSchemasJsonTypestatisticsPropertiesTypestatisticsAdditionalproperties}'},
    }

    def __init__(
        self,
        *,
        type_statistics: Optional[Dict[str, "ComponentsV9D1InSchemasJsonTypestatisticsPropertiesTypestatisticsAdditionalproperties"]] = None,
        **kwargs
    ):
        super(JsonTypeStatistics, self).__init__(**kwargs)
        self.type_statistics = type_statistics


class JsonUpdateRoleAssignmentRequest(msrest.serialization.Model):
    """The request for role assignment update operations.

    :param role_assignment_list:
    :type role_assignment_list: list[~PurviewCatalog.models.JsonRoleAssignmentEntry]
    """

    _attribute_map = {
        'role_assignment_list': {'key': 'roleAssignmentList', 'type': '[JsonRoleAssignmentEntry]'},
    }

    def __init__(
        self,
        *,
        role_assignment_list: Optional[List["JsonRoleAssignmentEntry"]] = None,
        **kwargs
    ):
        super(JsonUpdateRoleAssignmentRequest, self).__init__(**kwargs)
        self.role_assignment_list = role_assignment_list


class Paths16Dpt11AtlasV2GlossaryNameGlossarynameTermsImportPostRequestbodyContentMultipartFormDataSchema(msrest.serialization.Model):
    """Paths16Dpt11AtlasV2GlossaryNameGlossarynameTermsImportPostRequestbodyContentMultipartFormDataSchema.

    All required parameters must be populated in order to send to Azure.

    :param file: Required. The csv file to import glossary terms from.
    :type file: IO
    """

    _validation = {
        'file': {'required': True},
    }

    _attribute_map = {
        'file': {'key': 'file', 'type': 'IO'},
    }

    def __init__(
        self,
        *,
        file: IO,
        **kwargs
    ):
        super(Paths16Dpt11AtlasV2GlossaryNameGlossarynameTermsImportPostRequestbodyContentMultipartFormDataSchema, self).__init__(**kwargs)
        self.file = file


class PathsVoxj8WAtlasV2GlossaryGlossaryguidTermsImportPostRequestbodyContentMultipartFormDataSchema(msrest.serialization.Model):
    """PathsVoxj8WAtlasV2GlossaryGlossaryguidTermsImportPostRequestbodyContentMultipartFormDataSchema.

    All required parameters must be populated in order to send to Azure.

    :param file: Required. The csv file to import glossary terms from.
    :type file: IO
    """

    _validation = {
        'file': {'required': True},
    }

    _attribute_map = {
        'file': {'key': 'file', 'type': 'IO'},
    }

    def __init__(
        self,
        *,
        file: IO,
        **kwargs
    ):
        super(PathsVoxj8WAtlasV2GlossaryGlossaryguidTermsImportPostRequestbodyContentMultipartFormDataSchema, self).__init__(**kwargs)
        self.file = file


class XmlNs0Plist(msrest.serialization.Model):
    """Paginated-list, for returning search results.

    :param list: An array of objects.
    :type list: list[object]
    :param page_size: The size of the page.
    :type page_size: int
    :param sort_by: The sorted by field.
    :type sort_by: str
    :param sort_type: to specify whether the result should be sorted? If yes, whether asc or desc.
     Possible values include: "NONE", "ASC", "DESC".
    :type sort_type: str or ~PurviewCatalog.models.XmlNs0SortType
    :param start_index: The start index of the page.
    :type start_index: long
    :param total_count: The total count of items.
    :type total_count: long
    """

    _attribute_map = {
        'list': {'key': 'list', 'type': '[object]', 'xml': {}},
        'page_size': {'key': 'pageSize', 'type': 'int', 'xml': {}},
        'sort_by': {'key': 'sortBy', 'type': 'str', 'xml': {}},
        'sort_type': {'key': 'sortType', 'type': 'str'},
        'start_index': {'key': 'startIndex', 'type': 'long', 'xml': {}},
        'total_count': {'key': 'totalCount', 'type': 'long', 'xml': {}},
    }
    _xml_map = {
        'name': 'PList'
    }

    def __init__(
        self,
        *,
        list: Optional[List[object]] = None,
        page_size: Optional[int] = None,
        sort_by: Optional[str] = None,
        sort_type: Optional[Union[str, "XmlNs0SortType"]] = None,
        start_index: Optional[int] = None,
        total_count: Optional[int] = None,
        **kwargs
    ):
        super(XmlNs0Plist, self).__init__(**kwargs)
        self.list = list
        self.page_size = page_size
        self.sort_by = sort_by
        self.sort_type = sort_type
        self.start_index = start_index
        self.total_count = total_count


class XmlNs0SearchFilter(msrest.serialization.Model):
    """Generic filter, to specify search criteria using name/value pairs.

    :param get_count: Determines if get the count.
    :type get_count: bool
    :param max_rows: The maximum of rows.
    :type max_rows: long
    :param params: The parameter of the search.
    :type params: object
    :param sort_by: The sorted by field.
    :type sort_by: str
    :param sort_type: to specify whether the result should be sorted? If yes, whether asc or desc.
     Possible values include: "NONE", "ASC", "DESC".
    :type sort_type: str or ~PurviewCatalog.models.XmlNs0SortType
    :param start_index: The start index of the search.
    :type start_index: long
    """

    _attribute_map = {
        'get_count': {'key': 'getCount', 'type': 'bool', 'xml': {}},
        'max_rows': {'key': 'maxRows', 'type': 'long', 'xml': {}},
        'params': {'key': 'params', 'type': 'object'},
        'sort_by': {'key': 'sortBy', 'type': 'str', 'xml': {}},
        'sort_type': {'key': 'sortType', 'type': 'str'},
        'start_index': {'key': 'startIndex', 'type': 'long', 'xml': {}},
    }
    _xml_map = {
        'name': 'searchFilter'
    }

    def __init__(
        self,
        *,
        get_count: Optional[bool] = None,
        max_rows: Optional[int] = None,
        params: Optional[object] = None,
        sort_by: Optional[str] = None,
        sort_type: Optional[Union[str, "XmlNs0SortType"]] = None,
        start_index: Optional[int] = None,
        **kwargs
    ):
        super(XmlNs0SearchFilter, self).__init__(**kwargs)
        self.get_count = get_count
        self.max_rows = max_rows
        self.params = params
        self.sort_by = sort_by
        self.sort_type = sort_type
        self.start_index = start_index


class XmlNs0TimeBoundary(msrest.serialization.Model):
    """Captures time-boundary details.

    :param end_time: The end of the time boundary.
    :type end_time: str
    :param start_time: The start of the time boundary.
    :type start_time: str
    :param time_zone: The timezone of the time boundary.
    :type time_zone: str
    """

    _attribute_map = {
        'end_time': {'key': 'endTime', 'type': 'str', 'xml': {}},
        'start_time': {'key': 'startTime', 'type': 'str', 'xml': {}},
        'time_zone': {'key': 'timeZone', 'type': 'str', 'xml': {}},
    }
    _xml_map = {
        'name': 'timeBoundary'
    }

    def __init__(
        self,
        *,
        end_time: Optional[str] = None,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
        **kwargs
    ):
        super(XmlNs0TimeBoundary, self).__init__(**kwargs)
        self.end_time = end_time
        self.start_time = start_time
        self.time_zone = time_zone
