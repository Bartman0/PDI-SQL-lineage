# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from enum import Enum, EnumMeta
from six import with_metaclass

class _CaseInsensitiveEnumMeta(EnumMeta):
    def __getitem__(self, name):
        return super().__getitem__(name.upper())

    def __getattr__(cls, name):
        """Return the enum member matching `name`
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        try:
            return cls._member_map_[name.upper()]
        except KeyError:
            raise AttributeError(name)


class Enum14(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    ENUM = "enum"
    ENTITY = "entity"
    CLASSIFICATION = "classification"
    RELATIONSHIP = "relationship"
    STRUCT = "struct"
    TERM_TEMPLATE = "term_template"

class Enum7(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    BOTH = "BOTH"
    INPUT = "INPUT"
    OUTPUT = "OUTPUT"

class JsonAtlasTermAssignmentStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of terms assignment.
    """

    DISCOVERED = "DISCOVERED"
    PROPOSED = "PROPOSED"
    IMPORTED = "IMPORTED"
    VALIDATED = "VALIDATED"
    DEPRECATED = "DEPRECATED"
    OBSOLETE = "OBSOLETE"
    OTHER = "OTHER"

class JsonAtlasTermRelationshipStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of term relationship.
    """

    DRAFT = "DRAFT"
    ACTIVE = "ACTIVE"
    DEPRECATED = "DEPRECATED"
    OBSOLETE = "OBSOLETE"
    OTHER = "OTHER"

class JsonCardinality(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """single-valued attribute or multi-valued attribute.
    """

    SINGLE = "SINGLE"
    LIST = "LIST"
    SET = "SET"

class JsonCondition(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum for condition.
    """

    AND_ENUM = "AND"
    OR_ENUM = "OR"

class JsonEntityAuditActionV2(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of entity audit actions.
    """

    ENTITY_CREATE = "ENTITY_CREATE"
    ENTITY_UPDATE = "ENTITY_UPDATE"
    ENTITY_DELETE = "ENTITY_DELETE"
    ENTITY_IMPORT_CREATE = "ENTITY_IMPORT_CREATE"
    ENTITY_IMPORT_UPDATE = "ENTITY_IMPORT_UPDATE"
    ENTITY_IMPORT_DELETE = "ENTITY_IMPORT_DELETE"
    CLASSIFICATION_ADD = "CLASSIFICATION_ADD"
    CLASSIFICATION_DELETE = "CLASSIFICATION_DELETE"
    CLASSIFICATION_UPDATE = "CLASSIFICATION_UPDATE"
    PROPAGATED_CLASSIFICATION_ADD = "PROPAGATED_CLASSIFICATION_ADD"
    PROPAGATED_CLASSIFICATION_DELETE = "PROPAGATED_CLASSIFICATION_DELETE"
    PROPAGATED_CLASSIFICATION_UPDATE = "PROPAGATED_CLASSIFICATION_UPDATE"
    TERM_ADD = "TERM_ADD"
    TERM_DELETE = "TERM_DELETE"

class JsonEntityAuditType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of entity audit type.
    """

    ENTITY_AUDIT_V1 = "ENTITY_AUDIT_V1"
    ENTITY_AUDIT_V2 = "ENTITY_AUDIT_V2"

class JsonEntityOperation(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of entity operation.
    """

    CREATE = "CREATE"
    UPDATE = "UPDATE"
    PARTIAL_UPDATE = "PARTIAL_UPDATE"
    DELETE = "DELETE"

class JsonHookNotificationType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enum of hook notification type. Different behavior will be invoked by the value.
    """

    TYPE_CREATE = "TYPE_CREATE"
    TYPE_UPDATE = "TYPE_UPDATE"
    ENTITY_CREATE = "ENTITY_CREATE"
    ENTITY_PARTIAL_UPDATE = "ENTITY_PARTIAL_UPDATE"
    ENTITY_FULL_UPDATE = "ENTITY_FULL_UPDATE"
    ENTITY_DELETE = "ENTITY_DELETE"
    ENTITY_CREATE_V2 = "ENTITY_CREATE_V2"
    ENTITY_PARTIAL_UPDATE_V2 = "ENTITY_PARTIAL_UPDATE_V2"
    ENTITY_FULL_UPDATE_V2 = "ENTITY_FULL_UPDATE_V2"
    ENTITY_DELETE_V2 = "ENTITY_DELETE_V2"

class JsonImportCSVOperationStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enum of the status of import csv operation.
    """

    INIT = "INIT"
    SUCCEED = "SUCCEED"
    FAILED = "FAILED"
    RUNNING = "RUNNING"

class JsonLineageDirection(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of lineage direction.
    """

    INPUT = "INPUT"
    OUTPUT = "OUTPUT"
    BOTH = "BOTH"

class JsonOperator(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Supported search operations
    Logical comparision operators can only be used with numbers or dates
    IN, LIKE, startsWith, endsWith, CONTAINS can only be used with strings or text
    """

    LT = "LT"
    GT = "GT"
    LTE = "LTE"
    GTE = "GTE"
    EQ = "EQ"
    NEQ = "NEQ"
    IN_ENUM = "IN"
    LIKE = "LIKE"
    STARTS_WITH = "STARTS_WITH"
    ENDS_WITH = "ENDS_WITH"
    CONTAINS = "CONTAINS"
    CONTAINS_ANY = "CONTAINS_ANY"
    CONTAINS_ALL = "CONTAINS_ALL"
    IS_NULL = "IS_NULL"
    NOT_NULL = "NOT_NULL"

class JsonPropagateTags(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """PropagateTags indicates whether tags should propagate across the relationship instance.
    
    :code:`<p>`
    Tags can propagate:
    
    :code:`<p>`
    NONE - not at all :code:`<br>`
    ONE_TO_TWO - from end 1 to 2 :code:`<br>`
    TWO_TO_ONE - from end 2 to 1  :code:`<br>`
    BOTH - both ways
    
    :code:`<p>`
    Care needs to be taken when specifying. The use cases we are aware of where this flag is
    useful:
    
    :code:`<p>`
    
    
    * propagating confidentiality classifications from a table to columns - ONE_TO_TWO could be
    used here :code:`<br>`
    * propagating classifications around Glossary synonyms - BOTH could be used here.
      :code:`<p>`
      There is an expectation that further enhancements will allow more granular control of tag
    propagation and will
      address how to resolve conflicts.
    """

    NONE = "NONE"
    ONE_TO_TWO = "ONE_TO_TWO"
    TWO_TO_ONE = "TWO_TO_ONE"
    BOTH = "BOTH"

class JsonRelation(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of relations.
    """

    SEE_ALSO = "SEE_ALSO"
    SYNONYMS = "SYNONYMS"
    ANTONYMS = "ANTONYMS"
    PREFERRED_TO_TERMS = "PREFERRED_TO_TERMS"
    PREFERRED_TERMS = "PREFERRED_TERMS"
    REPLACEMENT_TERMS = "REPLACEMENT_TERMS"
    REPLACED_BY = "REPLACED_BY"
    TRANSLATION_TERMS = "TRANSLATION_TERMS"
    TRANSLATED_TERMS = "TRANSLATED_TERMS"
    ISA = "ISA"
    CLASSIFIES = "CLASSIFIES"
    VALID_VALUES = "VALID_VALUES"
    VALID_VALUES_FOR = "VALID_VALUES_FOR"

class JsonRelationshipCategory(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The Relationship category determines the style of relationship around containment and
    lifecycle.
    UML terminology is used for the values.
    
    :code:`<p>`
    ASSOCIATION is a relationship with no containment. :code:`<br>`
    COMPOSITION and AGGREGATION are containment relationships.
    
    :code:`<p>`
    The difference being in the lifecycles of the container and its children. In the COMPOSITION
    case,
    the children cannot exist without the container. For AGGREGATION, the life cycles
    of the container and children are totally independant.
    """

    ASSOCIATION = "ASSOCIATION"
    AGGREGATION = "AGGREGATION"
    COMPOSITION = "COMPOSITION"

class JsonRoundingMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of rounding mode.
    """

    UP = "UP"
    DOWN = "DOWN"
    CEILING = "CEILING"
    FLOOR = "FLOOR"
    HALF_UP = "HALF_UP"
    HALF_DOWN = "HALF_DOWN"
    HALF_EVEN = "HALF_EVEN"
    UNNECESSARY = "UNNECESSARY"

class JsonSavedSearchType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of saved search type.
    """

    BASIC = "BASIC"
    ADVANCED = "ADVANCED"

class JsonSortType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """to specify whether the result should be sorted? If yes, whether asc or desc.
    """

    NONE = "NONE"
    ASC = "ASC"
    DESC = "DESC"

class JsonStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Status of the entity - can be active or deleted. Deleted entities are not removed from Atlas
    store.
    """

    ACTIVE = "ACTIVE"
    DELETED = "DELETED"

class JsonStatusAtlasRelationship(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of relationship status.
    """

    ACTIVE = "ACTIVE"
    DELETED = "DELETED"

class JsonTermStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Status of the AtlasGlossaryTerm
    """

    DRAFT = "DRAFT"
    APPROVED = "APPROVED"
    ALERT = "ALERT"
    EXPIRED = "EXPIRED"

class JsonTypeCategory(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The enum of type category.
    """

    PRIMITIVE = "PRIMITIVE"
    OBJECT_ID_TYPE = "OBJECT_ID_TYPE"
    ENUM = "ENUM"
    STRUCT = "STRUCT"
    CLASSIFICATION = "CLASSIFICATION"
    ENTITY = "ENTITY"
    ARRAY = "ARRAY"
    MAP = "MAP"
    RELATIONSHIP = "RELATIONSHIP"
    TERM_TEMPLATE = "TERM_TEMPLATE"

class XmlNs0SortType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """to specify whether the result should be sorted? If yes, whether asc or desc.
    """

    NONE = "NONE"
    ASC = "ASC"
    DESC = "DESC"
