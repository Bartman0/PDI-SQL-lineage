# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, IO, List, Optional, TypeVar
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class GlossaryRESTOperations:
    """GlossaryRESTOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~PurviewCatalog.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def get_glossaries(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> List["_models.JsonAtlasGlossary"]:
        """Gets all glossaries registered with Atlas.

        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasGlossary, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasGlossary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.JsonAtlasGlossary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossaries.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[JsonAtlasGlossary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossaries.metadata = {'url': '/atlas/v2/glossary'}  # type: ignore

    async def create_glossary(
        self,
        atlas_glossary: "_models.JsonAtlasGlossary",
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossary"]:
        """Creates a glossary.

        :param atlas_glossary: Glossary definition, terms & categories can be anchored to a glossary.
         Using the anchor attribute when creating the Term/Category.
        :type atlas_glossary: ~PurviewCatalog.models.JsonAtlasGlossary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossary, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossary or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_glossary.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(atlas_glossary, 'JsonAtlasGlossary')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_glossary.metadata = {'url': '/atlas/v2/glossary'}  # type: ignore

    async def create_glossary_categories(
        self,
        glossary_category: List["_models.JsonAtlasGlossaryCategory"],
        **kwargs
    ) -> Optional[List["_models.JsonAtlasGlossaryCategory"]]:
        """Creates glossary category in bulk.

        :param glossary_category: An array of glossary category definitions to be created.
        :type glossary_category: list[~PurviewCatalog.models.JsonAtlasGlossaryCategory]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasGlossaryCategory, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasGlossaryCategory] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasGlossaryCategory"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_glossary_categories.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(glossary_category, '[JsonAtlasGlossaryCategory]')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasGlossaryCategory]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_glossary_categories.metadata = {'url': '/atlas/v2/glossary/categories'}  # type: ignore

    async def create_glossary_category(
        self,
        glossary_category: "_models.JsonAtlasGlossaryCategory",
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryCategory"]:
        """Creates a glossary category.

        :param glossary_category: The glossary category definition. A category must be anchored to a
         Glossary when creating.
         Optionally, terms belonging to the category and the hierarchy can also be defined during
         creation.
        :type glossary_category: ~PurviewCatalog.models.JsonAtlasGlossaryCategory
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryCategory, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryCategory or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryCategory"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_glossary_category.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(glossary_category, 'JsonAtlasGlossaryCategory')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_glossary_category.metadata = {'url': '/atlas/v2/glossary/category'}  # type: ignore

    async def get_glossary_category(
        self,
        category_guid: str,
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryCategory"]:
        """Gets specific glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category.
        :type category_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryCategory, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryCategory or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryCategory"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'categoryGuid': self._serialize.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary_category.metadata = {'url': '/atlas/v2/glossary/category/{categoryGuid}'}  # type: ignore

    async def update_glossary_category(
        self,
        category_guid: str,
        glossary_category: "_models.JsonAtlasGlossaryCategory",
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryCategory"]:
        """Updates the given glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category.
        :type category_guid: str
        :param glossary_category: The glossary category to be updated.
        :type glossary_category: ~PurviewCatalog.models.JsonAtlasGlossaryCategory
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryCategory, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryCategory or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryCategory"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_glossary_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'categoryGuid': self._serialize.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(glossary_category, 'JsonAtlasGlossaryCategory')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_glossary_category.metadata = {'url': '/atlas/v2/glossary/category/{categoryGuid}'}  # type: ignore

    async def delete_glossary_category(
        self,
        category_guid: str,
        **kwargs
    ) -> None:
        """Deletes a glossary category.

        :param category_guid: The globally unique identifier of the category.
        :type category_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_glossary_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'categoryGuid': self._serialize.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_glossary_category.metadata = {'url': '/atlas/v2/glossary/category/{categoryGuid}'}  # type: ignore

    async def partial_update_glossary_category(
        self,
        category_guid: str,
        partial_updates: Dict[str, str],
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryCategory"]:
        """Updates the glossary category partially.

        :param category_guid: The globally unique identifier of the category.
        :type category_guid: str
        :param partial_updates: A map containing keys as attribute names and values as corresponding
         attribute values for partial update.
        :type partial_updates: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryCategory, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryCategory or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryCategory"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.partial_update_glossary_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'categoryGuid': self._serialize.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(partial_updates, '{str}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    partial_update_glossary_category.metadata = {'url': '/atlas/v2/glossary/category/{categoryGuid}/partial'}  # type: ignore

    async def get_related_categories(
        self,
        category_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Dict[str, List["_models.JsonAtlasRelatedCategoryHeader"]]:
        """Gets all related categories (parent and children). Limit, offset, and sort parameters are
        currently not being enabled and won't work even they are passed.

        :param category_guid: The globally unique identifier of the category.
        :type category_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to list of JsonAtlasRelatedCategoryHeader, or the result of cls(response)
        :rtype: dict[str, list[~PurviewCatalog.models.JsonAtlasRelatedCategoryHeader]]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, List["_models.JsonAtlasRelatedCategoryHeader"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_related_categories.metadata['url']  # type: ignore
        path_format_arguments = {
            'categoryGuid': self._serialize.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('{[JsonAtlasRelatedCategoryHeader]}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_related_categories.metadata = {'url': '/atlas/v2/glossary/category/{categoryGuid}/related'}  # type: ignore

    async def get_category_terms(
        self,
        category_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[List["_models.JsonAtlasRelatedTermHeader"]]:
        """Gets all terms associated with the specific category.

        :param category_guid: The globally unique identifier of the category.
        :type category_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasRelatedTermHeader, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasRelatedTermHeader"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_category_terms.metadata['url']  # type: ignore
        path_format_arguments = {
            'categoryGuid': self._serialize.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasRelatedTermHeader]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_category_terms.metadata = {'url': '/atlas/v2/glossary/category/{categoryGuid}/terms'}  # type: ignore

    async def create_glossary_term(
        self,
        glossary_term: "_models.JsonAtlasGlossaryTerm",
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryTerm"]:
        """Creates a glossary term.

        :param glossary_term: The glossary term definition. A term must be anchored to a Glossary at
         the time of creation.
         Optionally it can be categorized as well.
        :type glossary_term: ~PurviewCatalog.models.JsonAtlasGlossaryTerm
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryTerm or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryTerm"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_glossary_term.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(glossary_term, 'JsonAtlasGlossaryTerm')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryTerm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_glossary_term.metadata = {'url': '/atlas/v2/glossary/term'}  # type: ignore

    async def get_glossary_term(
        self,
        term_guid: str,
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryTerm"]:
        """Gets a specific glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryTerm or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryTerm"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryTerm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary_term.metadata = {'url': '/atlas/v2/glossary/term/{termGuid}'}  # type: ignore

    async def update_glossary_term(
        self,
        term_guid: str,
        glossary_term: "_models.JsonAtlasGlossaryTerm",
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryTerm"]:
        """Updates the given glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param glossary_term: The glossary term to be updated.
        :type glossary_term: ~PurviewCatalog.models.JsonAtlasGlossaryTerm
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryTerm or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryTerm"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_glossary_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(glossary_term, 'JsonAtlasGlossaryTerm')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryTerm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_glossary_term.metadata = {'url': '/atlas/v2/glossary/term/{termGuid}'}  # type: ignore

    async def delete_glossary_term(
        self,
        term_guid: str,
        **kwargs
    ) -> None:
        """Deletes a glossary term.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_glossary_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_glossary_term.metadata = {'url': '/atlas/v2/glossary/term/{termGuid}'}  # type: ignore

    async def partial_update_glossary_term(
        self,
        term_guid: str,
        partial_updates: Dict[str, str],
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryTerm"]:
        """Updates the glossary term partially.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param partial_updates: A map containing keys as attribute names and values as corresponding
         attribute values to be updated.
        :type partial_updates: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryTerm or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryTerm"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.partial_update_glossary_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(partial_updates, '{str}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryTerm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    partial_update_glossary_term.metadata = {'url': '/atlas/v2/glossary/term/{termGuid}/partial'}  # type: ignore

    async def create_glossary_terms(
        self,
        glossary_term: List["_models.JsonAtlasGlossaryTerm"],
        **kwargs
    ) -> Optional[List["_models.JsonAtlasGlossaryTerm"]]:
        """Creates glossary terms in bulk.

        :param glossary_term: An array of glossary term definitions to be created in bulk.
        :type glossary_term: list[~PurviewCatalog.models.JsonAtlasGlossaryTerm]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasGlossaryTerm] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasGlossaryTerm"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_glossary_terms.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(glossary_term, '[JsonAtlasGlossaryTerm]')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasGlossaryTerm]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_glossary_terms.metadata = {'url': '/atlas/v2/glossary/terms'}  # type: ignore

    async def get_entities_assigned_with_term(
        self,
        term_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[List["_models.JsonAtlasRelatedObjectId"]]:
        """Gets all related objects assigned with the specified term.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasRelatedObjectId, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasRelatedObjectId] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasRelatedObjectId"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_entities_assigned_with_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasRelatedObjectId]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_entities_assigned_with_term.metadata = {'url': '/atlas/v2/glossary/terms/{termGuid}/assignedEntities'}  # type: ignore

    async def assign_term_to_entities(
        self,
        term_guid: str,
        related_object_ids: List["_models.JsonAtlasRelatedObjectId"],
        **kwargs
    ) -> None:
        """Assigns the given term to the provided list of related objects.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs to which the term has to be
         associated.
        :type related_object_ids: list[~PurviewCatalog.models.JsonAtlasRelatedObjectId]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.assign_term_to_entities.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(related_object_ids, '[JsonAtlasRelatedObjectId]')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    assign_term_to_entities.metadata = {'url': '/atlas/v2/glossary/terms/{termGuid}/assignedEntities'}  # type: ignore

    async def remove_term_assignment_from_entities(
        self,
        term_guid: str,
        related_object_ids: List["_models.JsonAtlasRelatedObjectId"],
        **kwargs
    ) -> None:
        """Deletes the term assignment for the given list of related objects.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs from which the term has to be
         dissociated.
        :type related_object_ids: list[~PurviewCatalog.models.JsonAtlasRelatedObjectId]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.remove_term_assignment_from_entities.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(related_object_ids, '[JsonAtlasRelatedObjectId]')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    remove_term_assignment_from_entities.metadata = {'url': '/atlas/v2/glossary/terms/{termGuid}/assignedEntities'}  # type: ignore

    async def delete_term_assignment_from_entities(
        self,
        term_guid: str,
        related_object_ids: List["_models.JsonAtlasRelatedObjectId"],
        **kwargs
    ) -> None:
        """Deletes the term assignment for the given list of related objects.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs from which the term has to be
         dissociated.
        :type related_object_ids: list[~PurviewCatalog.models.JsonAtlasRelatedObjectId]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.delete_term_assignment_from_entities.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(related_object_ids, '[JsonAtlasRelatedObjectId]')
        body_content_kwargs['content'] = body_content
        request = self._client.delete(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_term_assignment_from_entities.metadata = {'url': '/atlas/v2/glossary/terms/{termGuid}/assignedEntities'}  # type: ignore

    async def get_related_terms(
        self,
        term_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[Dict[str, List["_models.JsonAtlasRelatedTermHeader"]]]:
        """Gets all related terms for a specific term by its GUID. Limit, offset, and sort parameters are
        currently not being enabled and won't work even they are passed.

        :param term_guid: The globally unique identifier for glossary term.
        :type term_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to list of JsonAtlasRelatedTermHeader, or the result of cls(response)
        :rtype: dict[str, list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader]] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Dict[str, List["_models.JsonAtlasRelatedTermHeader"]]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_related_terms.metadata['url']  # type: ignore
        path_format_arguments = {
            'termGuid': self._serialize.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('{[JsonAtlasRelatedTermHeader]}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_related_terms.metadata = {'url': '/atlas/v2/glossary/terms/{termGuid}/related'}  # type: ignore

    async def get_glossary(
        self,
        glossary_guid: str,
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossary"]:
        """Gets a specific Glossary by its GUID.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossary, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossary or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}'}  # type: ignore

    async def update_glossary(
        self,
        glossary_guid: str,
        updated_glossary: "_models.JsonAtlasGlossary",
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossary"]:
        """Updates the given glossary.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param updated_glossary: The glossary definition to be updated.
        :type updated_glossary: ~PurviewCatalog.models.JsonAtlasGlossary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossary, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossary or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_glossary.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(updated_glossary, 'JsonAtlasGlossary')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_glossary.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}'}  # type: ignore

    async def delete_glossary(
        self,
        glossary_guid: str,
        **kwargs
    ) -> None:
        """Deletes a glossary.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_glossary.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_glossary.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}'}  # type: ignore

    async def get_glossary_categories(
        self,
        glossary_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[List["_models.JsonAtlasGlossaryCategory"]]:
        """Gets the categories belonging to a specific glossary.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasGlossaryCategory, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasGlossaryCategory] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasGlossaryCategory"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary_categories.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasGlossaryCategory]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary_categories.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/categories'}  # type: ignore

    async def get_glossary_categories_headers(
        self,
        glossary_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[List["_models.JsonAtlasRelatedCategoryHeader"]]:
        """Gets the category headers belonging to a specific glossary.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasRelatedCategoryHeader, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasRelatedCategoryHeader] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasRelatedCategoryHeader"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary_categories_headers.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasRelatedCategoryHeader]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary_categories_headers.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/categories/headers'}  # type: ignore

    async def get_detailed_glossary(
        self,
        glossary_guid: str,
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossaryExtInfo"]:
        """Gets a specific glossary with detailed information.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossaryExtInfo, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossaryExtInfo or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossaryExtInfo"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_detailed_glossary.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossaryExtInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_detailed_glossary.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/detailed'}  # type: ignore

    async def partial_update_glossary(
        self,
        glossary_guid: str,
        partial_updates: Dict[str, str],
        **kwargs
    ) -> Optional["_models.JsonAtlasGlossary"]:
        """Updates the glossary partially. Some properties such as qualifiedName are not allowed to be
        updated.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param partial_updates: A map containing keys as attribute names and values as corresponding
         attribute values.
        :type partial_updates: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasGlossary, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasGlossary or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasGlossary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.partial_update_glossary.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(partial_updates, '{str}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasGlossary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    partial_update_glossary.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/partial'}  # type: ignore

    async def get_glossary_terms(
        self,
        glossary_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[List["_models.JsonAtlasGlossaryTerm"]]:
        """Gets terms belonging to a specific glossary.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasGlossaryTerm] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasGlossaryTerm"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary_terms.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasGlossaryTerm]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary_terms.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/terms'}  # type: ignore

    async def get_glossary_term_headers(
        self,
        glossary_guid: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> Optional[List["_models.JsonAtlasRelatedTermHeader"]]:
        """Gets term headers belonging to a specific glossary.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasRelatedTermHeader, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasRelatedTermHeader] or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List["_models.JsonAtlasRelatedTermHeader"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_glossary_term_headers.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if self._config.sort is not None:
            query_parameters['sort'] = self._serialize.query("self._config.sort", self._config.sort, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[JsonAtlasRelatedTermHeader]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_glossary_term_headers.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/terms/headers'}  # type: ignore

    async def import_glossary_terms_via_csv(
        self,
        glossary_guid: str,
        file: IO,
        **kwargs
    ) -> Optional["_models.JsonImportCSVOperation"]:
        """Import Glossary Terms from local csv file.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param file: The csv file to import glossary terms from.
        :type file: IO
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonImportCSVOperation, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonImportCSVOperation or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonImportCSVOperation"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "multipart/form-data")
        accept = "application/json"

        # Construct URL
        url = self.import_glossary_terms_via_csv.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        # Construct form data
        _form_content = {
            'file': file,
        }
        request = self._client.post(url, query_parameters, header_parameters, form_content=_form_content)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('JsonImportCSVOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    import_glossary_terms_via_csv.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/terms/import'}  # type: ignore

    async def import_glossary_terms_via_csv_by_glossary_name(
        self,
        glossary_name: str,
        file: IO,
        **kwargs
    ) -> Optional["_models.JsonImportCSVOperation"]:
        """Import Glossary Terms from local csv file by glossaryName.

        :param glossary_name: The name of the glossary.
        :type glossary_name: str
        :param file: The csv file to import glossary terms from.
        :type file: IO
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonImportCSVOperation, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonImportCSVOperation or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonImportCSVOperation"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "multipart/form-data")
        accept = "application/json"

        # Construct URL
        url = self.import_glossary_terms_via_csv_by_glossary_name.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryName': self._serialize.url("glossary_name", glossary_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        # Construct form data
        _form_content = {
            'file': file,
        }
        request = self._client.post(url, query_parameters, header_parameters, form_content=_form_content)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('JsonImportCSVOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    import_glossary_terms_via_csv_by_glossary_name.metadata = {'url': '/atlas/v2/glossary/name/{glossaryName}/terms/import'}  # type: ignore

    async def get_import_csv_operation_status(
        self,
        operation_guid: str,
        **kwargs
    ) -> Optional["_models.JsonImportCSVOperation"]:
        """Get the status of import csv operation.

        :param operation_guid: The globally unique identifier for async operation/job`.
        :type operation_guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonImportCSVOperation, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonImportCSVOperation or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonImportCSVOperation"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_import_csv_operation_status.metadata['url']  # type: ignore
        path_format_arguments = {
            'operationGuid': self._serialize.url("operation_guid", operation_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonImportCSVOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_import_csv_operation_status.metadata = {'url': '/atlas/v2/glossary/terms/import/{operationGuid}'}  # type: ignore

    async def export_glossary_terms_as_csv(
        self,
        glossary_guid: str,
        term_guids: List[str],
        **kwargs
    ) -> None:
        """Export Glossary Terms as csv file.

        :param glossary_guid: The globally unique identifier for glossary.
        :type glossary_guid: str
        :param term_guids: An array of term guids.
        :type term_guids: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.export_glossary_terms_as_csv.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryGuid': self._serialize.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(term_guids, '[str]')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    export_glossary_terms_as_csv.metadata = {'url': '/atlas/v2/glossary/{glossaryGuid}/terms/export'}  # type: ignore

    async def get_terms_by_glossary_name(
        self,
        glossary_name: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        **kwargs
    ) -> List["_models.JsonAtlasGlossaryTerm"]:
        """Gets terms by glossary name.

        :param glossary_name: The name of the glossary.
        :type glossary_name: str
        :param limit: The page size - by default there is no paging.
        :type limit: int
        :param offset: The offset for pagination purpose.
        :type offset: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of JsonAtlasGlossaryTerm, or the result of cls(response)
        :rtype: list[~PurviewCatalog.models.JsonAtlasGlossaryTerm]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.JsonAtlasGlossaryTerm"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_terms_by_glossary_name.metadata['url']  # type: ignore
        path_format_arguments = {
            'glossaryName': self._serialize.url("glossary_name", glossary_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[JsonAtlasGlossaryTerm]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_terms_by_glossary_name.metadata = {'url': '/atlas/v2/glossary/name/{glossaryName}/terms'}  # type: ignore
