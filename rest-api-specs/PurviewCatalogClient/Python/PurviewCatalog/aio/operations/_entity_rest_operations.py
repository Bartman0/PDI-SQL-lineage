# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class EntityRESTOperations:
    """EntityRESTOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~PurviewCatalog.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def create_or_update(
        self,
        entity: "_models.JsonAtlasEntityWithExtInfo",
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Creates or updates an entity in Atlas.
        Existing entity is matched using its unique guid if supplied or by its unique attributes eg:
        qualifiedName.
        Map and array of collections are not well supported. E.g., array<array:code:`<int>`>,
        array<map<string, int>>.

        :param entity: Atlas entity with extended information.
        :type entity: ~PurviewCatalog.models.JsonAtlasEntityWithExtInfo
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_or_update.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(entity, 'JsonAtlasEntityWithExtInfo')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update.metadata = {'url': '/atlas/v2/entity'}  # type: ignore

    async def get_by_guids(
        self,
        guid: List[str],
        min_ext_info: Optional[bool] = False,
        ignore_relationships: Optional[bool] = False,
        **kwargs
    ) -> Optional["_models.JsonAtlasEntitiesWithExtInfo"]:
        """Lists entities in bulk identified by its GUIDs.

        :param guid: An array of GUIDs of entities to create.
        :type guid: list[str]
        :param min_ext_info: Whether to return minimal information for referred entities.
        :type min_ext_info: bool
        :param ignore_relationships: Whether to ignore relationship attributes.
        :type ignore_relationships: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasEntitiesWithExtInfo, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasEntitiesWithExtInfo or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.JsonAtlasEntitiesWithExtInfo"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_by_guids.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['guid'] = [self._serialize.query("guid", q, 'str') if q is not None else '' for q in guid]
        if min_ext_info is not None:
            query_parameters['minExtInfo'] = self._serialize.query("min_ext_info", min_ext_info, 'bool')
        if ignore_relationships is not None:
            query_parameters['ignoreRelationships'] = self._serialize.query("ignore_relationships", ignore_relationships, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JsonAtlasEntitiesWithExtInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_by_guids.metadata = {'url': '/atlas/v2/entity/bulk'}  # type: ignore

    async def create_or_update_bulk(
        self,
        entities: "_models.JsonAtlasEntitiesWithExtInfo",
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Creates or updates entities in Atlas in bulk.
        Existing entity is matched using its unique guid if supplied or by its unique attributes eg:
        qualifiedName.
        Map and array of collections are not well supported. E.g., array<array:code:`<int>`>,
        array<map<string, int>>.

        :param entities: An array of entities to create or update.
        :type entities: ~PurviewCatalog.models.JsonAtlasEntitiesWithExtInfo
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_or_update_bulk.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(entities, 'JsonAtlasEntitiesWithExtInfo')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_bulk.metadata = {'url': '/atlas/v2/entity/bulk'}  # type: ignore

    async def bulk_delete(
        self,
        guid: List[str],
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Deletes a list of entities in bulk identified by their GUIDs or unique attributes.

        :param guid: An array of GUIDs of entities to delete.
        :type guid: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.bulk_delete.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['guid'] = [self._serialize.query("guid", q, 'str') if q is not None else '' for q in guid]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    bulk_delete.metadata = {'url': '/atlas/v2/entity/bulk'}  # type: ignore

    async def add_classification(
        self,
        request: "_models.JsonClassificationAssociateRequest",
        **kwargs
    ) -> None:
        """Associates a classification to multiple entities in bulk.

        :param request: The request to associate a classification to multiple entities.
        :type request: ~PurviewCatalog.models.JsonClassificationAssociateRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.add_classification.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(request, 'JsonClassificationAssociateRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    add_classification.metadata = {'url': '/atlas/v2/entity/bulk/classification'}  # type: ignore

    async def get_by_id(
        self,
        guid: str,
        min_ext_info: Optional[bool] = False,
        ignore_relationships: Optional[bool] = False,
        **kwargs
    ) -> "_models.JsonAtlasEntityWithExtInfo":
        """Gets complete definition of an entity given its GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :param min_ext_info: Whether to return minimal information for referred entities.
        :type min_ext_info: bool
        :param ignore_relationships: Whether to ignore relationship attributes.
        :type ignore_relationships: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasEntityWithExtInfo, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasEntityWithExtInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonAtlasEntityWithExtInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_ext_info is not None:
            query_parameters['minExtInfo'] = self._serialize.query("min_ext_info", min_ext_info, 'bool')
        if ignore_relationships is not None:
            query_parameters['ignoreRelationships'] = self._serialize.query("ignore_relationships", ignore_relationships, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonAtlasEntityWithExtInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_by_id.metadata = {'url': '/atlas/v2/entity/guid/{guid}'}  # type: ignore

    async def partial_update_entity_attr_by_guid(
        self,
        guid: str,
        name: str,
        body: object,
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Updates entity partially - creates or updates entity attribute identified by its GUID.
        Supports only primitive attribute type and entity references.
        It does not support updation of complex types like arrays, and maps.
        Null updates are not possible.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :param name: The name of the attribute.
        :type name: str
        :param body: The value of the attribute.
        :type body: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.partial_update_entity_attr_by_guid.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['name'] = self._serialize.query("name", name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'object')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    partial_update_entity_attr_by_guid.metadata = {'url': '/atlas/v2/entity/guid/{guid}'}  # type: ignore

    async def delete_by_guid(
        self,
        guid: str,
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Deletes an entity identified by its GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_by_guid.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_by_guid.metadata = {'url': '/atlas/v2/entity/guid/{guid}'}  # type: ignore

    async def get_classification(
        self,
        guid: str,
        classification_name: str,
        **kwargs
    ) -> "_models.JsonAtlasClassification":
        """Lists classifications for a given entity represented by a GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :param classification_name: The name of the classification.
        :type classification_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasClassification, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasClassification
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonAtlasClassification"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_classification.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
            'classificationName': self._serialize.url("classification_name", classification_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonAtlasClassification', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_classification.metadata = {'url': '/atlas/v2/entity/guid/{guid}/classification/{classificationName}'}  # type: ignore

    async def delete_classification(
        self,
        guid: str,
        classification_name: str,
        **kwargs
    ) -> None:
        """Deletes a given classification from an existing entity represented by a GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :param classification_name: The name of the classification.
        :type classification_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_classification.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
            'classificationName': self._serialize.url("classification_name", classification_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_classification.metadata = {'url': '/atlas/v2/entity/guid/{guid}/classification/{classificationName}'}  # type: ignore

    async def get_classifications(
        self,
        guid: str,
        **kwargs
    ) -> "_models.JsonPlist":
        """Lists classifications for a given entity represented by a GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonPlist, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonPlist
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonPlist"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_classifications.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonPlist', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_classifications.metadata = {'url': '/atlas/v2/entity/guid/{guid}/classifications'}  # type: ignore

    async def add_classifications(
        self,
        guid: str,
        classifications: List["_models.JsonAtlasClassification"],
        **kwargs
    ) -> None:
        """Adds classifications to an existing entity represented by a GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :param classifications: An array of classifications to be added.
        :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.add_classifications.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(classifications, '[JsonAtlasClassification]')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    add_classifications.metadata = {'url': '/atlas/v2/entity/guid/{guid}/classifications'}  # type: ignore

    async def update_classifications(
        self,
        guid: str,
        classifications: List["_models.JsonAtlasClassification"],
        **kwargs
    ) -> None:
        """Updates classifications to an existing entity represented by a guid.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :param classifications: An array of classifications to be updated.
        :type classifications: list[~PurviewCatalog.models.JsonAtlasClassification]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_classifications.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(classifications, '[JsonAtlasClassification]')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    update_classifications.metadata = {'url': '/atlas/v2/entity/guid/{guid}/classifications'}  # type: ignore

    async def get_by_unique_attributes(
        self,
        type_name: str,
        min_ext_info: Optional[bool] = False,
        ignore_relationships: Optional[bool] = False,
        attr_qualified_name: Optional[str] = None,
        **kwargs
    ) -> "_models.JsonAtlasEntityWithExtInfo":
        """Gets complete definition of an entity given its type and unique attribute.
        In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:
        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        The REST request would look something like this:
        GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type.
        :type type_name: str
        :param min_ext_info: Whether to return minimal information for referred entities.
        :type min_ext_info: bool
        :param ignore_relationships: Whether to ignore relationship attributes.
        :type ignore_relationships: bool
        :param attr_qualified_name: The qualified name of the entity.
        :type attr_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasEntityWithExtInfo, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasEntityWithExtInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonAtlasEntityWithExtInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_by_unique_attributes.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_ext_info is not None:
            query_parameters['minExtInfo'] = self._serialize.query("min_ext_info", min_ext_info, 'bool')
        if ignore_relationships is not None:
            query_parameters['ignoreRelationships'] = self._serialize.query("ignore_relationships", ignore_relationships, 'bool')
        if attr_qualified_name is not None:
            query_parameters['attr:qualifiedName'] = self._serialize.query("attr_qualified_name", attr_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonAtlasEntityWithExtInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_by_unique_attributes.metadata = {'url': '/atlas/v2/entity/uniqueAttribute/type/{typeName}'}  # type: ignore

    async def partial_update_entity_by_unique_attrs(
        self,
        type_name: str,
        atlas_entity_with_ext_info: "_models.JsonAtlasEntityWithExtInfo",
        attr_qualified_name: Optional[str] = None,
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Updates entity partially - Allows a subset of attributes to be updated on
        an entity which is identified by its type and unique attribute  eg:
        Referenceable.qualifiedName.
        Null updates are not possible.
        In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:
        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        The REST request would look something like this:
        PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type.
        :type type_name: str
        :param atlas_entity_with_ext_info: Atlas entity with extended information.
        :type atlas_entity_with_ext_info: ~PurviewCatalog.models.JsonAtlasEntityWithExtInfo
        :param attr_qualified_name: The qualified name of the entity.
        :type attr_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.partial_update_entity_by_unique_attrs.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if attr_qualified_name is not None:
            query_parameters['attr:qualifiedName'] = self._serialize.query("attr_qualified_name", attr_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(atlas_entity_with_ext_info, 'JsonAtlasEntityWithExtInfo')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    partial_update_entity_by_unique_attrs.metadata = {'url': '/atlas/v2/entity/uniqueAttribute/type/{typeName}'}  # type: ignore

    async def delete_by_unique_attribute(
        self,
        type_name: str,
        attr_qualified_name: Optional[str] = None,
        **kwargs
    ) -> "_models.JsonEntityMutationResponse":
        """Deletes an entity identified by its type and unique attributes.
        In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:
        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        The REST request would look something like this:
        DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type.
        :type type_name: str
        :param attr_qualified_name: The qualified name of the entity.
        :type attr_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonEntityMutationResponse, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonEntityMutationResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonEntityMutationResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_by_unique_attribute.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if attr_qualified_name is not None:
            query_parameters['attr:qualifiedName'] = self._serialize.query("attr_qualified_name", attr_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonEntityMutationResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_by_unique_attribute.metadata = {'url': '/atlas/v2/entity/uniqueAttribute/type/{typeName}'}  # type: ignore

    async def delete_classification_by_unique_attribute(
        self,
        type_name: str,
        classification_name: str,
        attr_qualified_name: Optional[str] = None,
        **kwargs
    ) -> None:
        """Deletes a given classification from an entity identified by its type and unique attributes.

        :param type_name: The name of the type.
        :type type_name: str
        :param classification_name: The name of the classification.
        :type classification_name: str
        :param attr_qualified_name: The qualified name of the entity.
        :type attr_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_classification_by_unique_attribute.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
            'classificationName': self._serialize.url("classification_name", classification_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if attr_qualified_name is not None:
            query_parameters['attr:qualifiedName'] = self._serialize.query("attr_qualified_name", attr_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_classification_by_unique_attribute.metadata = {'url': '/atlas/v2/entity/uniqueAttribute/type/{typeName}/classification/{classificationName}'}  # type: ignore

    async def add_classifications_by_unique_attribute(
        self,
        type_name: str,
        atlas_classification_array: List["_models.JsonAtlasClassification"],
        attr_qualified_name: Optional[str] = None,
        **kwargs
    ) -> None:
        """Adds classification to the entity identified by its type and unique attributes.

        :param type_name: The name of the type.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be added.
        :type atlas_classification_array: list[~PurviewCatalog.models.JsonAtlasClassification]
        :param attr_qualified_name: The qualified name of the entity.
        :type attr_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.add_classifications_by_unique_attribute.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if attr_qualified_name is not None:
            query_parameters['attr:qualifiedName'] = self._serialize.query("attr_qualified_name", attr_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(atlas_classification_array, '[JsonAtlasClassification]')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    add_classifications_by_unique_attribute.metadata = {'url': '/atlas/v2/entity/uniqueAttribute/type/{typeName}/classifications'}  # type: ignore

    async def update_classifications_by_unique_attribute(
        self,
        type_name: str,
        atlas_classification_array: List["_models.JsonAtlasClassification"],
        attr_qualified_name: Optional[str] = None,
        **kwargs
    ) -> None:
        """Updates classification on an entity identified by its type and unique attributes.

        :param type_name: The name of the type.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be updated.
        :type atlas_classification_array: list[~PurviewCatalog.models.JsonAtlasClassification]
        :param attr_qualified_name: The qualified name of the entity.
        :type attr_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_classifications_by_unique_attribute.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if attr_qualified_name is not None:
            query_parameters['attr:qualifiedName'] = self._serialize.query("attr_qualified_name", attr_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(atlas_classification_array, '[JsonAtlasClassification]')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    update_classifications_by_unique_attribute.metadata = {'url': '/atlas/v2/entity/uniqueAttribute/type/{typeName}/classifications'}  # type: ignore

    async def set_classifications(
        self,
        entity_headers: "_models.JsonAtlasEntityHeaders",
        **kwargs
    ) -> List[str]:
        """set classifications on entities in bulk.

        :param entity_headers: Atlas entity headers.
        :type entity_headers: ~PurviewCatalog.models.JsonAtlasEntityHeaders
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.set_classifications.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(entity_headers, 'JsonAtlasEntityHeaders')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    set_classifications.metadata = {'url': '/atlas/v2/entity/bulk/setClassifications'}  # type: ignore

    async def get_entities_by_unique_attributes(
        self,
        type_name: str,
        min_ext_info: Optional[bool] = False,
        ignore_relationships: Optional[bool] = False,
        attr_n_qualified_name: Optional[str] = None,
        **kwargs
    ) -> "_models.JsonAtlasEntitiesWithExtInfo":
        """Bulk API to retrieve list of entities identified by its unique attributes.

        In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format

        typeName=:code:`<typeName>`&attr_1::code:`<attrName>`=:code:`<attrValue>`&attr_2::code:`<attrName>`=:code:`<attrValue>`&attr_3::code:`<attrName>`=:code:`<attrValue>`

        NOTE: The attrName should be an unique attribute for the given entity-type

        The REST request would look something like this

        GET
        /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_0:qualifiedName=db1@cl1&attr_2:qualifiedName=db2@cl1.

        :param type_name: The name of the type.
        :type type_name: str
        :param min_ext_info: Whether to return minimal information for referred entities.
        :type min_ext_info: bool
        :param ignore_relationships: Whether to ignore relationship attributes.
        :type ignore_relationships: bool
        :param attr_n_qualified_name: Qualified name of an entity. E.g. to find 2 entities you can set
         attrs_0:qualifiedName=db1@cl1&attrs_2:qualifiedName=db2@cl1.
        :type attr_n_qualified_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasEntitiesWithExtInfo, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasEntitiesWithExtInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonAtlasEntitiesWithExtInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_entities_by_unique_attributes.metadata['url']  # type: ignore
        path_format_arguments = {
            'typeName': self._serialize.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_ext_info is not None:
            query_parameters['minExtInfo'] = self._serialize.query("min_ext_info", min_ext_info, 'bool')
        if ignore_relationships is not None:
            query_parameters['ignoreRelationships'] = self._serialize.query("ignore_relationships", ignore_relationships, 'bool')
        if attr_n_qualified_name is not None:
            query_parameters['attr_N:qualifiedName'] = self._serialize.query("attr_n_qualified_name", attr_n_qualified_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonAtlasEntitiesWithExtInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_entities_by_unique_attributes.metadata = {'url': '/atlas/v2/entity/bulk/uniqueAttribute/type/{typeName}'}  # type: ignore

    async def get_header_by_id(
        self,
        guid: str,
        **kwargs
    ) -> "_models.JsonAtlasEntityHeader":
        """Get entity header given its GUID.

        Get entity header given its GUID.

        :param guid: The globally unique identifier of the entity.
        :type guid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JsonAtlasEntityHeader, or the result of cls(response)
        :rtype: ~PurviewCatalog.models.JsonAtlasEntityHeader
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JsonAtlasEntityHeader"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_header_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'guid': self._serialize.url("guid", guid, 'str', max_length=4096, min_length=1),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JsonAtlasEntityHeader', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_header_by_id.metadata = {'url': '/atlas/v2/entity/guid/{guid}/header'}  # type: ignore
