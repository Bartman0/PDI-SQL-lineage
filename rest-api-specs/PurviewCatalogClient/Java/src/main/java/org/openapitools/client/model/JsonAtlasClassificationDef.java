/*
 * Purview Catalog Service REST API Document
 * Purview Catalog Service is a fully managed cloud service whose users can discover the data sources they need and understand the data sources they find. At the same time, Data Catalog helps organizations get more value from their existing investments. This swagger defines REST API of the Hot Tier of Data Catalog Gen 2.
 *
 * The version of the OpenAPI document: 2020-12-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.JsonAtlasAttributeDef;
import org.openapitools.client.model.JsonAtlasClassificationDefAllOf;
import org.openapitools.client.model.JsonAtlasStructDef;
import org.openapitools.client.model.JsonDateFormat;
import org.openapitools.client.model.JsonTypeCategory;

/**
 * class that captures details of a classification-type.
 */
@ApiModel(description = "class that captures details of a classification-type.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2021-01-21T11:36:33.263002+01:00[Europe/Amsterdam]")
public class JsonAtlasClassificationDef {
  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private JsonTypeCategory category;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private BigDecimal createTime;

  public static final String SERIALIZED_NAME_CREATED_BY = "createdBy";
  @SerializedName(SERIALIZED_NAME_CREATED_BY)
  private String createdBy;

  public static final String SERIALIZED_NAME_DATE_FORMATTER = "dateFormatter";
  @SerializedName(SERIALIZED_NAME_DATE_FORMATTER)
  private JsonDateFormat dateFormatter;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_GUID = "guid";
  @SerializedName(SERIALIZED_NAME_GUID)
  private String guid;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  private Map<String, String> options = null;

  public static final String SERIALIZED_NAME_SERVICE_TYPE = "serviceType";
  @SerializedName(SERIALIZED_NAME_SERVICE_TYPE)
  private String serviceType;

  public static final String SERIALIZED_NAME_TYPE_VERSION = "typeVersion";
  @SerializedName(SERIALIZED_NAME_TYPE_VERSION)
  private String typeVersion;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private BigDecimal updateTime;

  public static final String SERIALIZED_NAME_UPDATED_BY = "updatedBy";
  @SerializedName(SERIALIZED_NAME_UPDATED_BY)
  private String updatedBy;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private BigDecimal version;

  public static final String SERIALIZED_NAME_LAST_MODIFIED_T_S = "lastModifiedTS";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED_T_S)
  private String lastModifiedTS;

  public static final String SERIALIZED_NAME_ATTRIBUTE_DEFS = "attributeDefs";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTE_DEFS)
  private List<JsonAtlasAttributeDef> attributeDefs = null;

  public static final String SERIALIZED_NAME_ENTITY_TYPES = "entityTypes";
  @SerializedName(SERIALIZED_NAME_ENTITY_TYPES)
  private List<String> entityTypes = null;

  public static final String SERIALIZED_NAME_SUB_TYPES = "subTypes";
  @SerializedName(SERIALIZED_NAME_SUB_TYPES)
  private List<String> subTypes = null;

  public static final String SERIALIZED_NAME_SUPER_TYPES = "superTypes";
  @SerializedName(SERIALIZED_NAME_SUPER_TYPES)
  private List<String> superTypes = null;


  public JsonAtlasClassificationDef category(JsonTypeCategory category) {
    
    this.category = category;
    return this;
  }

   /**
   * Get category
   * @return category
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public JsonTypeCategory getCategory() {
    return category;
  }


  public void setCategory(JsonTypeCategory category) {
    this.category = category;
  }


  public JsonAtlasClassificationDef createTime(BigDecimal createTime) {
    
    this.createTime = createTime;
    return this;
  }

   /**
   * The created time of the record.
   * @return createTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The created time of the record.")

  public BigDecimal getCreateTime() {
    return createTime;
  }


  public void setCreateTime(BigDecimal createTime) {
    this.createTime = createTime;
  }


  public JsonAtlasClassificationDef createdBy(String createdBy) {
    
    this.createdBy = createdBy;
    return this;
  }

   /**
   * The user who created the record.
   * @return createdBy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The user who created the record.")

  public String getCreatedBy() {
    return createdBy;
  }


  public void setCreatedBy(String createdBy) {
    this.createdBy = createdBy;
  }


  public JsonAtlasClassificationDef dateFormatter(JsonDateFormat dateFormatter) {
    
    this.dateFormatter = dateFormatter;
    return this;
  }

   /**
   * Get dateFormatter
   * @return dateFormatter
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public JsonDateFormat getDateFormatter() {
    return dateFormatter;
  }


  public void setDateFormatter(JsonDateFormat dateFormatter) {
    this.dateFormatter = dateFormatter;
  }


  public JsonAtlasClassificationDef description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * The description of the type definition.
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The description of the type definition.")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public JsonAtlasClassificationDef guid(String guid) {
    
    this.guid = guid;
    return this;
  }

   /**
   * The GUID of the type definition.
   * @return guid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The GUID of the type definition.")

  public String getGuid() {
    return guid;
  }


  public void setGuid(String guid) {
    this.guid = guid;
  }


  public JsonAtlasClassificationDef name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name of the type definition.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name of the type definition.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public JsonAtlasClassificationDef options(Map<String, String> options) {
    
    this.options = options;
    return this;
  }

  public JsonAtlasClassificationDef putOptionsItem(String key, String optionsItem) {
    if (this.options == null) {
      this.options = new HashMap<String, String>();
    }
    this.options.put(key, optionsItem);
    return this;
  }

   /**
   * The options for the type definition.
   * @return options
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The options for the type definition.")

  public Map<String, String> getOptions() {
    return options;
  }


  public void setOptions(Map<String, String> options) {
    this.options = options;
  }


  public JsonAtlasClassificationDef serviceType(String serviceType) {
    
    this.serviceType = serviceType;
    return this;
  }

   /**
   * The service type.
   * @return serviceType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The service type.")

  public String getServiceType() {
    return serviceType;
  }


  public void setServiceType(String serviceType) {
    this.serviceType = serviceType;
  }


  public JsonAtlasClassificationDef typeVersion(String typeVersion) {
    
    this.typeVersion = typeVersion;
    return this;
  }

   /**
   * The version of the type.
   * @return typeVersion
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The version of the type.")

  public String getTypeVersion() {
    return typeVersion;
  }


  public void setTypeVersion(String typeVersion) {
    this.typeVersion = typeVersion;
  }


  public JsonAtlasClassificationDef updateTime(BigDecimal updateTime) {
    
    this.updateTime = updateTime;
    return this;
  }

   /**
   * The update time of the record.
   * @return updateTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The update time of the record.")

  public BigDecimal getUpdateTime() {
    return updateTime;
  }


  public void setUpdateTime(BigDecimal updateTime) {
    this.updateTime = updateTime;
  }


  public JsonAtlasClassificationDef updatedBy(String updatedBy) {
    
    this.updatedBy = updatedBy;
    return this;
  }

   /**
   * The user who updated the record.
   * @return updatedBy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The user who updated the record.")

  public String getUpdatedBy() {
    return updatedBy;
  }


  public void setUpdatedBy(String updatedBy) {
    this.updatedBy = updatedBy;
  }


  public JsonAtlasClassificationDef version(BigDecimal version) {
    
    this.version = version;
    return this;
  }

   /**
   * The version of the record.
   * @return version
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The version of the record.")

  public BigDecimal getVersion() {
    return version;
  }


  public void setVersion(BigDecimal version) {
    this.version = version;
  }


  public JsonAtlasClassificationDef lastModifiedTS(String lastModifiedTS) {
    
    this.lastModifiedTS = lastModifiedTS;
    return this;
  }

   /**
   * ETag for concurrency control.
   * @return lastModifiedTS
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "ETag for concurrency control.")

  public String getLastModifiedTS() {
    return lastModifiedTS;
  }


  public void setLastModifiedTS(String lastModifiedTS) {
    this.lastModifiedTS = lastModifiedTS;
  }


  public JsonAtlasClassificationDef attributeDefs(List<JsonAtlasAttributeDef> attributeDefs) {
    
    this.attributeDefs = attributeDefs;
    return this;
  }

  public JsonAtlasClassificationDef addAttributeDefsItem(JsonAtlasAttributeDef attributeDefsItem) {
    if (this.attributeDefs == null) {
      this.attributeDefs = new ArrayList<JsonAtlasAttributeDef>();
    }
    this.attributeDefs.add(attributeDefsItem);
    return this;
  }

   /**
   * An array of attribute definitions.
   * @return attributeDefs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of attribute definitions.")

  public List<JsonAtlasAttributeDef> getAttributeDefs() {
    return attributeDefs;
  }


  public void setAttributeDefs(List<JsonAtlasAttributeDef> attributeDefs) {
    this.attributeDefs = attributeDefs;
  }


  public JsonAtlasClassificationDef entityTypes(List<String> entityTypes) {
    
    this.entityTypes = entityTypes;
    return this;
  }

  public JsonAtlasClassificationDef addEntityTypesItem(String entityTypesItem) {
    if (this.entityTypes == null) {
      this.entityTypes = new ArrayList<String>();
    }
    this.entityTypes.add(entityTypesItem);
    return this;
  }

   /**
   * Specifying a list of entityType names in the classificationDef, ensures that classifications can only be applied to those entityTypes. &lt;ul&gt; &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt; &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt; &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt; &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt; &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt; &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt; &lt;/ul&gt;
   * @return entityTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifying a list of entityType names in the classificationDef, ensures that classifications can only be applied to those entityTypes. <ul> <li>Any subtypes of the entity types inherit the restriction</li> <li>Any classificationDef subtypes inherit the parents entityTypes restrictions</li> <li>Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes</li> <li>An empty entityTypes list when there are no parent restrictions means there are no restrictions</li> <li>An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions</li> <li>If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs</li> </ul>")

  public List<String> getEntityTypes() {
    return entityTypes;
  }


  public void setEntityTypes(List<String> entityTypes) {
    this.entityTypes = entityTypes;
  }


  public JsonAtlasClassificationDef subTypes(List<String> subTypes) {
    
    this.subTypes = subTypes;
    return this;
  }

  public JsonAtlasClassificationDef addSubTypesItem(String subTypesItem) {
    if (this.subTypes == null) {
      this.subTypes = new ArrayList<String>();
    }
    this.subTypes.add(subTypesItem);
    return this;
  }

   /**
   * An array of sub types.
   * @return subTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of sub types.")

  public List<String> getSubTypes() {
    return subTypes;
  }


  public void setSubTypes(List<String> subTypes) {
    this.subTypes = subTypes;
  }


  public JsonAtlasClassificationDef superTypes(List<String> superTypes) {
    
    this.superTypes = superTypes;
    return this;
  }

  public JsonAtlasClassificationDef addSuperTypesItem(String superTypesItem) {
    if (this.superTypes == null) {
      this.superTypes = new ArrayList<String>();
    }
    this.superTypes.add(superTypesItem);
    return this;
  }

   /**
   * An array of super types.
   * @return superTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of super types.")

  public List<String> getSuperTypes() {
    return superTypes;
  }


  public void setSuperTypes(List<String> superTypes) {
    this.superTypes = superTypes;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JsonAtlasClassificationDef jsonAtlasClassificationDef = (JsonAtlasClassificationDef) o;
    return Objects.equals(this.category, jsonAtlasClassificationDef.category) &&
        Objects.equals(this.createTime, jsonAtlasClassificationDef.createTime) &&
        Objects.equals(this.createdBy, jsonAtlasClassificationDef.createdBy) &&
        Objects.equals(this.dateFormatter, jsonAtlasClassificationDef.dateFormatter) &&
        Objects.equals(this.description, jsonAtlasClassificationDef.description) &&
        Objects.equals(this.guid, jsonAtlasClassificationDef.guid) &&
        Objects.equals(this.name, jsonAtlasClassificationDef.name) &&
        Objects.equals(this.options, jsonAtlasClassificationDef.options) &&
        Objects.equals(this.serviceType, jsonAtlasClassificationDef.serviceType) &&
        Objects.equals(this.typeVersion, jsonAtlasClassificationDef.typeVersion) &&
        Objects.equals(this.updateTime, jsonAtlasClassificationDef.updateTime) &&
        Objects.equals(this.updatedBy, jsonAtlasClassificationDef.updatedBy) &&
        Objects.equals(this.version, jsonAtlasClassificationDef.version) &&
        Objects.equals(this.lastModifiedTS, jsonAtlasClassificationDef.lastModifiedTS) &&
        Objects.equals(this.attributeDefs, jsonAtlasClassificationDef.attributeDefs) &&
        Objects.equals(this.entityTypes, jsonAtlasClassificationDef.entityTypes) &&
        Objects.equals(this.subTypes, jsonAtlasClassificationDef.subTypes) &&
        Objects.equals(this.superTypes, jsonAtlasClassificationDef.superTypes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(category, createTime, createdBy, dateFormatter, description, guid, name, options, serviceType, typeVersion, updateTime, updatedBy, version, lastModifiedTS, attributeDefs, entityTypes, subTypes, superTypes);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JsonAtlasClassificationDef {\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    dateFormatter: ").append(toIndentedString(dateFormatter)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    guid: ").append(toIndentedString(guid)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    serviceType: ").append(toIndentedString(serviceType)).append("\n");
    sb.append("    typeVersion: ").append(toIndentedString(typeVersion)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    updatedBy: ").append(toIndentedString(updatedBy)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    lastModifiedTS: ").append(toIndentedString(lastModifiedTS)).append("\n");
    sb.append("    attributeDefs: ").append(toIndentedString(attributeDefs)).append("\n");
    sb.append("    entityTypes: ").append(toIndentedString(entityTypes)).append("\n");
    sb.append("    subTypes: ").append(toIndentedString(subTypes)).append("\n");
    sb.append("    superTypes: ").append(toIndentedString(superTypes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

